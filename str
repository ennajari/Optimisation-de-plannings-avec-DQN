le voila mon projet :
titre :Assistant Personnel pour la Gestion du Temps
algorithme :Deep Q-Network
environnement/Don√©es : Donn√©es d'agenda personnel et historiques d'activit√©s
methodes a utiliser : - Analyse des habitudes et pr√©f√©rences de l'utilisateur
- Application de DQN pour sugg√©rer des plannings optimaux
- √âvaluation bas√©e sur l'am√©lioration de la productivit√© et la satisfaction de l'utilisateur
le voila mon structure :
üìÅ Optimisation-de-plannings-avec-DQN/
‚îú‚îÄ‚îÄ üìÅ Data/                  # Donn√©es du projet
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Processed/        # Donn√©es pr√©trait√©es
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ activity_encoder.pkl
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cleaned_data.csv
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ raw/              # Donn√©es brutes
‚îÇ       ‚îî‚îÄ‚îÄ atus_full_selected.csv
‚îú‚îÄ‚îÄ üìÅ environment/          # Environnement RL personnalis√©
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ schedule_env.py  # Impl√©mentation de l'environnement Gym
‚îú‚îÄ‚îÄ üìÅ models/              # Mod√®les entra√Æn√©s
‚îÇ   ‚îú‚îÄ‚îÄ dqn_final.h5
‚îÇ   ‚îî‚îÄ‚îÄ dqn_schedule_model.h5
‚îú‚îÄ‚îÄ üìÅ notebooks/           # Notebooks Jupyter
‚îÇ   ‚îú‚îÄ‚îÄ 2_data_preprocessing.ipynb  # Pr√©traitement des donn√©es
‚îÇ   ‚îî‚îÄ‚îÄ 3_dqn_training.ipynb       # Entra√Ænement du DQN
‚îî‚îÄ‚îÄ üìÅ ui/                  # Interface utilisateur
    ‚îî‚îÄ‚îÄ üìÑ app.py          # Application Streamlit

le voila mon code pour le fichiers schedule_env.py
"""
Environnement de planification pour l'Assistant Personnel de Gestion du Temps
Utilise un format compatible avec OpenAI Gym pour l'apprentissage par renforcement
"""
import numpy as np
import pandas as pd
import gym
from gym import spaces
from datetime import datetime, timedelta
import os

class ScheduleEnv(gym.Env):
    """
    Environnement de simulation pour la planification d'agenda personnel
    utilisant le format OpenAI Gym pour l'apprentissage par renforcement.
    """
    
    metadata = {'render.modes': ['human']}
    
    def __init__(self, data_path=None, user_id=None, n_time_slots=24, max_activities=10):
        super(ScheduleEnv, self).__init__()
        
        # Param√®tres de l'environnement
        self.n_time_slots = n_time_slots  # 24 cr√©neaux horaires (un par heure)
        self.max_activities = max_activities  # Nombre maximum d'activit√©s √† planifier
        self.days_of_week = 7  # Jour de la semaine (1-7)
        self.activity_types = None  # Sera d√©fini lors du chargement des donn√©es
        
        # Charger et pr√©processer les donn√©es
        self.load_user_data(data_path, user_id)
        
        # D√©finir l'espace d'actions : 
        # Pour chaque activit√©, on peut la planifier √† n'importe quel cr√©neau horaire
        # Actions: (activit√©_id, cr√©neau_horaire)
        self.action_space = spaces.MultiDiscrete([
            len(self.activity_types), 
            self.n_time_slots
        ])
        
        # D√©finir l'espace d'observation
        # √âtat: matrice [n_time_slots x n_activity_types] + vecteur jour de la semaine (one-hot)
        self.observation_space = spaces.Dict({
            'schedule': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.n_time_slots, len(self.activity_types)), 
                dtype=np.float32
            ),
            'day_of_week': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.days_of_week,), 
                dtype=np.float32
            ),
            'time_remaining': spaces.Box(
                low=0, 
                high=self.n_time_slots, 
                shape=(1,), 
                dtype=np.float32
            )
        })
        
        # √âtat actuel de l'environnement
        self.current_schedule = None
        self.current_day = None
        self.available_time = None
        self.scheduled_activities = None
        
        # Historique des activit√©s pour l'apprentissage des pr√©f√©rences utilisateur
        self.activity_history = None
        
        # Reset pour initialiser l'environnement
        self.reset()
    
    def load_user_data(self, data_path, user_id=None):
        """
        Charge les donn√©es d'activit√©s d'un utilisateur sp√©cifique ou d'un ensemble d'utilisateurs.
        Ne conserve que les colonnes essentielles pour le projet.
        """
        if data_path is None:
            # Cr√©er des donn√©es synth√©tiques pour les tests
            self._create_synthetic_data()
            return
        
        try:
            # Charger les donn√©es
            data = pd.read_csv(data_path)
            
            # Filtrer uniquement les colonnes essentielles
            essential_cols = ['TUCASEID', 'TUACTIVITY_N', 'TUACTDUR24', 
                             'TUSTARTTIM', 'ACTIVITY_NAME', 'TUDIARYDAY']
            data = data[essential_cols]
            
            # Filtrer pour un utilisateur sp√©cifique si fourni
            if user_id:
                data = data[data['TUCASEID'] == user_id]
            
            # Extraire les types d'activit√©s uniques
            self.activity_types = data['ACTIVITY_NAME'].unique()
            
            # Convertir les heures de d√©but en format num√©rique (minutes depuis minuit)
            data['start_time_minutes'] = data['TUSTARTTIM'].apply(self._convert_time_to_minutes)
            
            # Calculer les heures de fin
            data['end_time_minutes'] = data['start_time_minutes'] + data['TUACTDUR24']
            
            # Stocker les donn√©es trait√©es
            self.user_data = data
            
            # Calculer les statistiques des activit√©s pour l'apprentissage des pr√©f√©rences
            self._compute_activity_statistics()
            
        except Exception as e:
            print(f"Erreur lors du chargement des donn√©es: {str(e)}")
            # Cr√©er des donn√©es synth√©tiques en cas d'erreur
            self._create_synthetic_data()
    
    def _convert_time_to_minutes(self, time_str):
        """Convertit une cha√Æne de temps HH:MM en minutes depuis minuit."""
        try:
            hours, minutes = map(int, time_str.split(':'))
            return hours * 60 + minutes
        except:
            # Imputer la moyenne des heures pour l'activit√© si disponible
            return 8 * 60  # Fallback: 8h du matin
    
    def _create_synthetic_data(self):
        """Cr√©e des donn√©es synth√©tiques pour les tests."""
        # D√©finir des types d'activit√©s de base
        self.activity_types = np.array([
            'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
            'Sommeil', 'T√¢ches m√©nag√®res', 'Courses', 'Socialisation', 'Apprentissage'
        ])
        
        # Cr√©er un dataframe avec des donn√©es synth√©tiques
        n_samples = 100
        synthetic_data = {
            'TUCASEID': np.ones(n_samples),
            'TUACTIVITY_N': np.arange(n_samples),
            'ACTIVITY_NAME': np.random.choice(self.activity_types, n_samples),
            'TUACTDUR24': np.random.randint(15, 240, n_samples),  # 15min √† 4h
            'start_time_minutes': np.random.randint(0, 24*60, n_samples),
            'TUDIARYDAY': np.random.randint(1, 8, n_samples)  # 1-7 (lundi-dimanche)
        }
        
        # Calculer les heures de fin
        synthetic_data['end_time_minutes'] = synthetic_data['start_time_minutes'] + synthetic_data['TUACTDUR24']
        
        # Convertir en dataframe
        self.user_data = pd.DataFrame(synthetic_data)
        
        # Calculer les statistiques des activit√©s
        self._compute_activity_statistics()
    
    def _compute_activity_statistics(self):
        """Calcule les statistiques des activit√©s pour l'apprentissage des pr√©f√©rences."""
        # Grouper par type d'activit√© et jour de la semaine
        grouped = self.user_data.groupby(['ACTIVITY_NAME', 'TUDIARYDAY'])
        
        # Calculer la dur√©e moyenne par activit√© et par jour
        self.avg_duration = grouped['TUACTDUR24'].mean().reset_index()
        
        # Calculer l'heure de d√©but moyenne par activit√© et par jour
        self.avg_start_time = grouped['start_time_minutes'].mean().reset_index()
        
        # Calculer la fr√©quence des activit√©s par jour
        self.activity_frequency = grouped.size().reset_index(name='frequency')
    
    def reset(self):
        """R√©initialise l'environnement et retourne l'√©tat initial."""
        # Choisir un jour al√©atoire de la semaine (1-7)
        self.current_day = np.random.randint(1, 8)
        
        # Initialiser un agenda vide
        self.current_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Initialiser le temps disponible (24 heures = 24 cr√©neaux)
        self.available_time = self.n_time_slots
        
        # Initialiser la liste des activit√©s planifi√©es
        self.scheduled_activities = []
        
        # Cr√©er un vecteur one-hot pour le jour de la semaine
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1  # -1 car l'indexation commence √† 0
        
        # Retourner l'√©tat initial
        return {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
    
    def step(self, action):
        """
        Ex√©cute une action dans l'environnement et retourne le nouvel √©tat,
        la r√©compense, le statut de fin et des informations suppl√©mentaires.
        
        Action: (activit√©_id, cr√©neau_horaire)
        """
        activity_id, time_slot = action
        activity_name = self.activity_types[activity_id]
        
        # V√©rifier si le cr√©neau horaire est disponible
        if self.current_schedule[time_slot].sum() > 0:
            reward = -1.0  # P√©nalit√© pour conflit horaire
            done = False
            info = {'status': 'conflict', 'activity': activity_name, 'time_slot': time_slot}
        else:
            # Planifier l'activit√©
            self.current_schedule[time_slot, activity_id] = 1
            self.available_time -= 1
            self.scheduled_activities.append((activity_name, time_slot))
            
            # Calculer la r√©compense bas√©e sur les pr√©f√©rences utilisateur
            reward = self._compute_reward(activity_name, time_slot)
            
            # V√©rifier si toutes les activit√©s ont √©t√© planifi√©es ou si le temps est √©coul√©
            done = len(self.scheduled_activities) >= self.max_activities or self.available_time <= 0
            
            info = {'status': 'scheduled', 'activity': activity_name, 'time_slot': time_slot}
        
        # Construire le nouvel √©tat
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1
        
        state = {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
        
        return state, reward, done, info
    
    def _compute_reward(self, activity_name, time_slot):
        """
        Calcule la r√©compense pour une activit√© planifi√©e √† un cr√©neau horaire sp√©cifique,
        bas√© sur les pr√©f√©rences historiques de l'utilisateur.
        """
        # Convertir le cr√©neau horaire en minutes (1 cr√©neau = 1 heure = 60 minutes)
        scheduled_time = time_slot * 60
        
        # Trouver les statistiques pour cette activit√© et ce jour de la semaine
        act_stats = self.avg_start_time[
            (self.avg_start_time['ACTIVITY_NAME'] == activity_name) & 
            (self.avg_start_time['TUDIARYDAY'] == self.current_day)
        ]
        
        if not act_stats.empty:
            # Calculer la diff√©rence entre l'heure planifi√©e et l'heure pr√©f√©r√©e (en minutes)
            preferred_time = act_stats['start_time_minutes'].values[0]
            time_diff = abs(scheduled_time - preferred_time)
            
            # La r√©compense diminue avec l'√©cart par rapport √† l'heure pr√©f√©r√©e
            # Normaliser pour que la r√©compense soit entre 0 et 1
            time_reward = max(0, 1 - (time_diff / (12 * 60)))  # max 12h de diff√©rence
        else:
            # Si nous n'avons pas d'information sur cette activit√© pour ce jour
            time_reward = 0.5  # R√©compense neutre
        
        # Bonus pour une planification coh√©rente (activit√©s similaires regroup√©es)
        coherence_reward = 0
        if len(self.scheduled_activities) > 0:
            for prev_activity, prev_slot in self.scheduled_activities:
                # R√©compense pour les activit√©s similaires regroup√©es
                if prev_activity == activity_name and abs(prev_slot - time_slot) <= 1:
                    coherence_reward += 0.2
                # P√©nalit√© pour les activit√©s qui devraient √™tre espac√©es
                elif prev_activity == activity_name and abs(prev_slot - time_slot) < 3:
                    coherence_reward -= 0.1
        
        # La r√©compense finale est une combinaison de r√©compenses bas√©es sur le temps et la coh√©rence
        reward = time_reward + coherence_reward
        
        return reward
    
    def render(self, mode='human'):
        """Affiche l'√©tat actuel de l'environnement pour le d√©bogage."""
        if mode != 'human':
            return
        
        print("\n===== √âTAT ACTUEL DE L'AGENDA =====")
        print(f"Jour de la semaine: {self.current_day}")
        print(f"Temps restant: {self.available_time} cr√©neaux")
        print("\nActivit√©s planifi√©es:")
        
        for i, (activity, time_slot) in enumerate(self.scheduled_activities):
            print(f"{i+1}. {activity} √† {time_slot}:00")
        
        print("\nGrille horaire:")
        for slot in range(self.n_time_slots):
            activities = [self.activity_types[i] for i in range(len(self.activity_types)) 
                         if self.current_schedule[slot, i] > 0]
            print(f"{slot}:00 - {activities if activities else 'Libre'}")
        
        print("====================================\n")
    
    def close(self):
        """Lib√®re les ressources."""
        pass

    def get_optimal_schedule(self):
        """
        G√©n√®re un emploi du temps optimal bas√© sur les pr√©f√©rences utilisateur.
        Utilis√© pour comparer les performances du mod√®le DQN.
        """
        # Cr√©er un agenda vide
        optimal_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Filtrer les activit√©s pour le jour actuel
        day_activities = self.avg_start_time[self.avg_start_time['TUDIARYDAY'] == self.current_day]
        
        # Trier par fr√©quence (priorit√© aux activit√©s les plus fr√©quentes)
        day_activities = day_activities.merge(self.activity_frequency, 
                                          on=['ACTIVITY_NAME', 'TUDIARYDAY'])
        day_activities = day_activities.sort_values('frequency', ascending=False)
        
        # Planifier les activit√©s √† leur heure pr√©f√©r√©e
        for _, row in day_activities.iterrows():
            activity_name = row['ACTIVITY_NAME']
            preferred_time_minutes = row['start_time_minutes']
            
            # Convertir en cr√©neau horaire (arrondi √† l'heure la plus proche)
            preferred_slot = int(round(preferred_time_minutes / 60)) % self.n_time_slots
            
            # V√©rifier si le cr√©neau est disponible
            if optimal_schedule[preferred_slot].sum() == 0:
                # Trouver l'index de l'activit√©
                activity_idx = np.where(self.activity_types == activity_name)[0][0]
                
                # Planifier l'activit√©
                optimal_schedule[preferred_slot, activity_idx] = 1
            else:
                # Chercher le cr√©neau disponible le plus proche
                for offset in range(1, self.n_time_slots // 2):
                    # Essayer le cr√©neau avant
                    before_slot = (preferred_slot - offset) % self.n_time_slots
                    if optimal_schedule[before_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[before_slot, activity_idx] = 1
                        break
                    
                    # Essayer le cr√©neau apr√®s
                    after_slot = (preferred_slot + offset) % self.n_time_slots
                    if optimal_schedule[after_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[after_slot, activity_idx] = 1
                        break
        
        return optimal_schedule
le voila mon code pour le fichiers app.py
"""
Application Streamlit pour l'Assistant Personnel de Gestion du Temps
Utilise un mod√®le DQN pour optimiser les plannings personnels des utilisateurs
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow.keras.models import load_model
import sys
import os
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path

# Ajouter le r√©pertoire parent au chemin pour importer les modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from environment.schedule_env import ScheduleEnv

# Configuration de la page
st.set_page_config(
    page_title="Assistant Personnel de Gestion du Temps",
    page_icon="üìÖ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Chemins de fichiers
MODEL_PATH = '../models/dqn_schedule_model.h5'
DATA_PATH = '../Data/processed/cleaned_data.csv'
DEFAULT_ACTIVITIES = [
    'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
    'Sommeil', 'T√¢ches m√©nag√®res', 'Courses', 'Socialisation', 'Apprentissage'
]
ACTIVITY_COLORS = {
    'Travail': '#FF6B6B',
    'Repas': '#4ECDC4',
    'Transport': '#FFD166',
    'Loisirs': '#6B5B95',
    'Sport': '#88D8B0',
    'Sommeil': '#5D535E',
    'T√¢ches m√©nag√®res': '#F7B801',
    'Courses': '#F18701',
    'Socialisation': '#7BDFF2',
    'Apprentissage': '#B2DBBF'
}
# Pour toute autre activit√©, utiliser une couleur par d√©faut
DEFAULT_COLOR = '#CCCCCC'

# Fonction pour charger le mod√®le
@st.cache_resource
def load_dqn_model():
    """Charge le mod√®le DQN pr√©-entra√Æn√©"""
    try:
        model = load_model(MODEL_PATH)
        return model
    except Exception as e:
        st.error(f"Erreur lors du chargement du mod√®le: {str(e)}")
        return None

# Fonction pour charger les donn√©es
@st.cache_data
def load_data():
    """Charge les donn√©es pr√©trait√©es"""
    try:
        data = pd.read_csv(DATA_PATH)
        return data
    except Exception as e:
        st.warning(f"Erreur lors du chargement des donn√©es: {str(e)}")
        st.info("Utilisation de donn√©es par d√©faut")
        return None

# Cr√©er un environnement Gym pour l'optimisation de planning
def create_environment(data=None, user_activities=None):
    """Cr√©e l'environnement de simulation pour l'optimisation de planning"""
    if user_activities is None:
        user_activities = DEFAULT_ACTIVITIES
    
    env = ScheduleEnv(data_path=DATA_PATH if data is not None else None)
    
    # Si l'utilisateur a fourni des activit√©s personnalis√©es, les utiliser
    if user_activities:
        env.activity_types = np.array(user_activities)
    
    return env

# Fonction pour g√©n√©rer un planning optimis√© avec DQN
def generate_optimized_schedule(env, model, user_constraints=None, day_of_week=None):
    """
    G√©n√®re un planning optimis√© en utilisant le mod√®le DQN
    
    Args:
        env: Environnement de simulation
        model: Mod√®le DQN pr√©-entra√Æn√©
        user_constraints: Dictionnaire de contraintes utilisateur
        day_of_week: Jour de la semaine sp√©cifique (1-7, lundi-dimanche)
        
    Returns:
        schedule: Planning g√©n√©r√© (matrice)
        activities: Liste des activit√©s planifi√©es (avec heures)
        rewards: R√©compenses obtenues
    """
    # Reset de l'environnement
    state = env.reset()
    
    # Si un jour sp√©cifique est fourni, le d√©finir manuellement
    if day_of_week is not None:
        env.current_day = day_of_week
        # Recr√©er le vecteur one-hot pour le jour
        day_of_week_vector = np.zeros(env.days_of_week)
        day_of_week_vector[env.current_day - 1] = 1
        state['day_of_week'] = day_of_week_vector
    
    # Appliquer les contraintes utilisateur si disponibles
    if user_constraints:
        # Exemple: bloquer certains cr√©neaux horaires ou d√©finir des activit√©s obligatoires
        for activity, time_slots in user_constraints.items():
            if activity in env.activity_types:
                activity_idx = np.where(env.activity_types == activity)[0][0]
                for slot in time_slots:
                    if 0 <= slot < env.n_time_slots:
                        env.current_schedule[slot, activity_idx] = 1
                        env.available_time -= 1
    
    done = False
    total_reward = 0
    activities_planned = []
    
    # Simuler les actions du mod√®le DQN
    while not done and env.available_time > 0:
        # Pr√©parer l'√©tat pour la pr√©diction
        schedule_flat = state['schedule'].flatten()
        day_of_week = state['day_of_week']
        time_remaining = state['time_remaining']
        state_tensor = np.concatenate([schedule_flat, day_of_week, time_remaining])
        state_tensor = np.expand_dims(state_tensor, 0)
        
        # Pr√©dire l'action avec le mod√®le
        act_values = model.predict(state_tensor, verbose=0)[0]
        
        # Convertir l'index plat en (activit√©, cr√©neau)
        n_activities = len(env.activity_types)
        action_idx = np.argmax(act_values)
        activity_id = action_idx // env.n_time_slots
        time_slot = action_idx % env.n_time_slots
        action = np.array([activity_id, time_slot])
        
        # V√©rifier si le cr√©neau est d√©j√† occup√©
        while env.current_schedule[action[1]].sum() > 0:
            # Masquer cette action et trouver la prochaine meilleure
            act_values[action_idx] = -np.inf
            action_idx = np.argmax(act_values)
            activity_id = action_idx // env.n_time_slots
            time_slot = action_idx % env.n_time_slots
            action = np.array([activity_id, time_slot])
            
            # Si toutes les actions sont masqu√©es, terminer
            if np.all(act_values == -np.inf):
                done = True
                break
        
        if not done:
            # Ex√©cuter l'action s√©lectionn√©e
            next_state, reward, done, info = env.step(action)
            
            # Mettre √† jour l'√©tat et la r√©compense
            state = next_state
            total_reward += reward
            
            # Enregistrer l'activit√© planifi√©e
            activity_name = env.activity_types[action[0]]
            time_slot = action[1]
            activities_planned.append((activity_name, time_slot, reward))
    
    return env.current_schedule, activities_planned, total_reward

# Fonction pour visualiser le planning avec Plotly
def visualize_schedule_plotly(schedule, activities, activity_types):
    """Cr√©e une visualisation interactive du planning avec Plotly"""
    # Cr√©er un dataframe pour la visualisation
    schedule_data = []
    
    for slot in range(schedule.shape[0]):
        for activity_idx in range(schedule.shape[1]):
            if schedule[slot, activity_idx] > 0:
                activity = activity_types[activity_idx]
                schedule_data.append({
                    'Heure': f"{slot:02d}:00",
                    'Activit√©': activity,
                    'Valeur': 1,
                    'Couleur': ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
                })
    
    if not schedule_data:
        return go.Figure()
    
    schedule_df = pd.DataFrame(schedule_data)
    
    # Cr√©er la visualisation avec Plotly
    fig = px.timeline(
        schedule_df, 
        x_start="Heure", 
        y="Activit√©", 
        color="Activit√©",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Journalier Optimis√©"
    )
    
    # Personnaliser l'apparence
    fig.update_layout(
        xaxis_title="Heure de la journ√©e",
        yaxis_title="Activit√©",
        height=600,
        showlegend=True
    )
    
    return fig

# Fonction pour cr√©er un calendrier hebdomadaire
def create_weekly_calendar(daily_schedules, activity_types):
    """Cr√©e un calendrier hebdomadaire √† partir des plannings quotidiens"""
    days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']
    calendar_data = []
    
    for day_idx, day_name in enumerate(days):
        if day_idx < len(daily_schedules):
            schedule = daily_schedules[day_idx]
            
            for slot in range(schedule.shape[0]):
                for activity_idx in range(schedule.shape[1]):
                    if schedule[slot, activity_idx] > 0:
                        activity = activity_types[activity_idx]
                        calendar_data.append({
                            'Jour': day_name,
                            'Heure': f"{slot:02d}:00",
                            'Activit√©': activity,
                            'Couleur': ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
                        })
    
    if not calendar_data:
        return go.Figure()
    
    calendar_df = pd.DataFrame(calendar_data)
    
    # Cr√©er la visualisation avec Plotly
    fig = px.timeline(
        calendar_df, 
        x="Heure", 
        y="Jour", 
        color="Activit√©",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Hebdomadaire Optimis√©"
    )
    
    # Personnaliser l'apparence
    fig.update_layout(
        xaxis_title="Heure de la journ√©e",
        yaxis_title="Jour de la semaine",
        height=600,
        showlegend=True
    )
    
    return fig

# Fonction pour calculer des statistiques sur le planning
def calculate_schedule_stats(activities):
    """Calcule des statistiques sur le planning g√©n√©r√©"""
    if not activities:
        return {}
    
    # Compter les activit√©s par type
    activity_counts = {}
    for activity, time_slot, reward in activities:
        if activity in activity_counts:
            activity_counts[activity] += 1
        else:
            activity_counts[activity] = 1
    
    # Calculer les heures les plus productives
    rewards_by_hour = {}
    for activity, time_slot, reward in activities:
        if time_slot in rewards_by_hour:
            rewards_by_hour[time_slot] += reward
        else:
            rewards_by_hour[time_slot] = reward
    
    # Trouver l'heure la plus productive
    most_productive_hour = max(rewards_by_hour, key=rewards_by_hour.get) if rewards_by_hour else None
    
    return {
        'activity_counts': activity_counts,
        'rewards_by_hour': rewards_by_hour,
        'most_productive_hour': most_productive_hour
    }

# Interface utilisateur avec Streamlit
def main():
    # Titre de l'application
    st.title("üìÖ Assistant Personnel de Gestion du Temps")
    st.subheader("Optimisez votre planning quotidien avec l'intelligence artificielle")
    
    # Chargement du mod√®le et des donn√©es
    model = load_dqn_model()
    data = load_data()
    
    if model is None:
        st.error("Le mod√®le DQN n'a pas pu √™tre charg√©. Veuillez v√©rifier le fichier mod√®le.")
        return
    
    # Sidebar pour les param√®tres
    st.sidebar.title("Param√®tres")
    
    # Option pour choisir entre planning quotidien ou hebdomadaire
    planning_type = st.sidebar.radio(
        "Type de planning",
        ["üìÜ Planning quotidien", "üóìÔ∏è Planning hebdomadaire"]
    )
    
    # Option pour choisir le jour de la semaine
    day_options = {
        "Lundi": 1, "Mardi": 2, "Mercredi": 3, "Jeudi": 4, 
        "Vendredi": 5, "Samedi": 6, "Dimanche": 7
    }
    
    if planning_type == "üìÜ Planning quotidien":
        selected_day_name = st.sidebar.selectbox(
            "Jour de la semaine",
            list(day_options.keys())
        )
        selected_day = day_options[selected_day_name]
    else:
        selected_day = None
    
    # Param√®tres personnalis√©s
    st.sidebar.subheader("Activit√©s personnalis√©es")
    
    # Option pour utiliser les activit√©s par d√©faut ou personnalis√©es
    use_default_activities = st.sidebar.checkbox("Utiliser les activit√©s par d√©faut", value=True)
    
    if use_default_activities:
        activities = DEFAULT_ACTIVITIES
    else:
        # Champ texte pour entrer les activit√©s personnalis√©es
        custom_activities_input = st.sidebar.text_area(
            "Entrez vos activit√©s (une par ligne)",
            value="\n".join(DEFAULT_ACTIVITIES)
        )
        activities = [act.strip() for act in custom_activities_input.split("\n") if act.strip()]
    
    # Affichage des activit√©s
    st.sidebar.subheader("Liste des activit√©s")
    for i, activity in enumerate(activities):
        color = ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
        st.sidebar.markdown(
            f"<div style='background-color:{color}; padding:5px; border-radius:5px; margin:2px 0;'>"
            f"{i+1}. {activity}</div>",
            unsafe_allow_html=True
        )
    
    # Contraintes utilisateur
    st.sidebar.subheader("Contraintes (optionnel)")
    add_constraints = st.sidebar.checkbox("Ajouter des contraintes horaires")
    
    user_constraints = {}
    if add_constraints:
        # Interface pour ajouter des contraintes
        constraint_activity = st.sidebar.selectbox(
            "Activit√©",
            activities
        )
        
        constraint_time = st.sidebar.multiselect(
            "Horaires (obligatoires)",
            [f"{h:02d}:00" for h in range(24)]
        )
        
        if st.sidebar.button("Ajouter cette contrainte"):
            time_slots = [int(t.split(":")[0]) for t in constraint_time]
            if constraint_activity in user_constraints:
                user_constraints[constraint_activity].extend(time_slots)
            else:
                user_constraints[constraint_activity] = time_slots
    
    # Affichage des contraintes
    if user_constraints:
        st.sidebar.subheader("Contraintes ajout√©es")
        for activity, slots in user_constraints.items():
            st.sidebar.write(f"{activity}: {', '.join([f'{s:02d}:00' for s in slots])}")
    
    # Bouton pour g√©n√©rer le planning
    if planning_type == "üìÜ Planning quotidien":
        generate_button = st.sidebar.button("G√©n√©rer planning quotidien")
    else:
        generate_button = st.sidebar.button("G√©n√©rer planning hebdomadaire")
    
    # Corps principal de l'application
    if generate_button:
        with st.spinner("G√©n√©ration du planning en cours..."):
            # Cr√©er l'environnement
            env = create_environment(data, activities)
            
            if planning_type == "üìÜ Planning quotidien":
                # G√©n√©rer un planning quotidien
                schedule, activities_planned, total_reward = generate_optimized_schedule(
                    env, model, user_constraints, selected_day
                )
                
                # Afficher le planning
                st.subheader(f"Planning optimis√© pour {selected_day_name}")
                
                # Visualisation du planning avec Plotly
                fig = visualize_schedule_plotly(schedule, activities_planned, env.activity_types)
                st.plotly_chart(fig, use_container_width=True)
                
                # Afficher les activit√©s planifi√©es
                if activities_planned:
                    st.subheader("D√©tail des activit√©s")
                    
                    activities_df = pd.DataFrame([(act, f"{slot:02d}:00", f"{reward:.2f}") 
                                                for act, slot, reward in activities_planned],
                                               columns=["Activit√©", "Heure", "Score"])
                    
                    st.dataframe(activities_df.sort_values(by="Heure"), use_container_width=True)
                    
                    # Calculer et afficher des statistiques
                    stats = calculate_schedule_stats(activities_planned)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("Distribution des activit√©s")
                        if stats['activity_counts']:
                            fig = px.pie(
                                values=list(stats['activity_counts'].values()),
                                names=list(stats['activity_counts'].keys()),
                                title="Distribution des activit√©s",
                                color=list(stats['activity_counts'].keys()),
                                color_discrete_map=ACTIVITY_COLORS
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with col2:
                        st.subheader("Productivit√© par heure")
                        if stats['rewards_by_hour']:
                            hours = [f"{h:02d}:00" for h in stats['rewards_by_hour'].keys()]
                            rewards = list(stats['rewards_by_hour'].values())
                            
                            fig = px.bar(
                                x=hours,
                                y=rewards,
                                title="Score de productivit√© par heure",
                                labels={'x': 'Heure', 'y': 'Score de productivit√©'}
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    # Afficher l'heure la plus productive
                    if stats['most_productive_hour'] is not None:
                        st.info(f"‚ú® Votre heure la plus productive est {stats['most_productive_hour']:02d}:00")
                
                # Qualit√© du planning
                st.subheader("√âvaluation du planning")
                st.write(f"Score total du planning: {total_reward:.2f}")
                
                # Jauge de qualit√©
                quality = min(max(total_reward / 10, 0), 1)  # Normaliser entre 0 et 1
                
                gauge = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=quality * 100,
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': "Qualit√© du planning"},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 33], 'color': "red"},
                            {'range': [33, 66], 'color': "yellow"},
                            {'range': [66, 100], 'color': "green"}
                        ]
                    }
                ))
                
                st.plotly_chart(gauge, use_container_width=True)
                
                # Ajouter des recommandations
                st.subheader("Recommandations")
                
                if quality < 0.4:
                    st.warning("Votre planning pourrait √™tre am√©lior√©. Essayez d'ajouter plus de contraintes ou de modifier vos activit√©s.")
                elif quality < 0.7:
                    st.info("Votre planning est bon, mais il pourrait encore √™tre optimis√©.")
                else:
                    st.success("Excellent planning ! Votre journ√©e est optimis√©e pour une productivit√© maximale.")
            
            else:
                # G√©n√©rer un planning hebdomadaire
                st.subheader("Planning hebdomadaire optimis√©")
                
                daily_schedules = []
                all_activities_planned = []
                total_weekly_reward = 0
                
                # G√©n√©rer un planning pour chaque jour de la semaine
                for day in range(1, 8):
                    day_schedule, day_activities, day_reward = generate_optimized_schedule(
                        env, model, user_constraints, day
                    )
                    daily_schedules.append(day_schedule)
                    all_activities_planned.extend([(act, slot, reward, day) for act, slot, reward in day_activities])
                    total_weekly_reward += day_reward
                
                # Visualiser le calendrier hebdomadaire
                fig = create_weekly_calendar(daily_schedules, env.activity_types)
                st.plotly_chart(fig, use_container_width=True)
                
                # Afficher les statistiques hebdomadaires
                st.subheader("Statistiques hebdomadaires")
                
                # Pr√©parer les donn√©es pour les statistiques
                activities_by_day = {}
                for day_idx in range(7):
                    day_name = list(day_options.keys())[day_idx]
                    day_activities = [act for act, _, _, day in all_activities_planned if day == day_idx + 1]
                    activities_by_day[day_name] = len(day_activities)
                
                # Afficher la distribution des activit√©s par jour
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Activit√©s par jour")
                    fig = px.bar(
                        x=list(activities_by_day.keys()),
                        y=list(activities_by_day.values()),
                        title="Nombre d'activit√©s par jour",
                        labels={'x': 'Jour', 'y': 'Nombre d\'activit√©s'}
                    )
                    st.plotly_chart(fig, use_container_width=True)
                
                with col2:
                    st.subheader("Score hebdomadaire")
                    st.write(f"Score total de la semaine: {total_weekly_reward:.2f}")
                    
                    # Jauge de qualit√© hebdomadaire
                    quality = min(max(total_weekly_reward / 70, 0), 1)  # Normaliser entre 0 et 1
                    
                    gauge = go.Figure(go.Indicator(
                        mode="gauge+number",
                        value=quality * 100,
                        domain={'x': [0, 1], 'y': [0, 1]},
                        title={'text': "Qualit√© du planning hebdomadaire"},
                        gauge={
                            'axis': {'range': [0, 100]},
                            'bar': {'color': "darkblue"},
                            'steps': [
                                {'range': [0, 33], 'color': "red"},
                                {'range': [33, 66], 'color': "yellow"},
                                {'range': [66, 100], 'color': "green"}
                            ]
                        }
                    ))
                    
                    st.plotly_chart(gauge, use_container_width=True)
                
                # Afficher les activit√©s les plus fr√©quentes
                activity_counts = {}
                for act, _, _, _ in all_activities_planned:
                    if act in activity_counts:
                        activity_counts[act] += 1
                    else:
                        activity_counts[act] = 1
                
                st.subheader("R√©partition des activit√©s sur la semaine")
                fig = px.pie(
                    values=list(activity_counts.values()),
                    names=list(activity_counts.keys()),
                    title="Distribution des activit√©s sur la semaine",
                    color=list(activity_counts.keys()),
                    color_discrete_map=ACTIVITY_COLORS
                )
                st.plotly_chart(fig, use_container_width=True)
                
                # T√©l√©chargement du planning
                st.subheader("Exporter le planning")
                
                # Cr√©er un dataframe pour l'exportation
                export_data = []
                days = list(day_options.keys())
                
                for day_idx, day_name in enumerate(days):
                    day_activities = [(act, slot) for act, slot, _, day in all_activities_planned if day == day_idx + 1]
                    for activity, time_slot in day_activities:
                        export_data.append({
                            'Jour': day_name,
                            'Heure': f"{time_slot:02d}:00",
                            'Activit√©': activity
                        })
                
                export_df = pd.DataFrame(export_data)
                
                # Cr√©er un fichier CSV pour l'exportation
                csv = export_df.to_csv(index=False)
                st.download_button(
                    label="T√©l√©charger le planning (CSV)",
                    data=csv,
                    file_name=f"planning_hebdomadaire_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv"
                )
    
    else:
        # Afficher l'introduction de l'application
        st.write("""
        Bienvenue dans votre Assistant Personnel de Gestion du Temps ! Cette application utilise l'intelligence artificielle
        pour vous aider √† optimiser votre emploi du temps quotidien ou hebdomadaire.
        
        ### üß† Comment √ßa marche ?
        
        Notre application utilise un algorithme d'apprentissage par renforcement appel√© **Deep Q-Network (DQN)** pour analyser vos habitudes
        et pr√©f√©rences, puis g√©n√©rer un planning optimis√© qui maximise votre productivit√© et votre satisfaction.
        
        ### üöÄ Fonctionnalit√©s
        
        - **Planning quotidien**: Obtenez un emploi du temps optimis√© pour une journ√©e sp√©cifique
        - **Planning hebdomadaire**: Visualisez un calendrier complet pour toute la semaine
        - **Activit√©s personnalis√©es**: D√©finissez vos propres types d'activit√©s
        - **Contraintes horaires**: Ajoutez des activit√©s obligatoires √† des heures pr√©cises
        - **Statistiques**: Analysez la qualit√© de votre planning et identifiez vos heures les plus productives
        
        ### üìä Commencer
        
        Utilisez les options dans la barre lat√©rale pour personnaliser votre planning, puis cliquez sur "G√©n√©rer planning" pour voir les r√©sultats.
        """)
        
        # Ajouter une image ou un sch√©ma explicatif
        st.image("https://via.placeholder.com/800x400?text=Assistant+Personnel+de+Gestion+du+Temps", 
                 caption="Optimisez votre temps avec l'IA")

# Ex√©cuter l'application
if __name__ == "__main__":
    main()
le voila mon code pour le fichiers 2_data_preprocessing.ipynb:
import pandas as pd
from sklearn.preprocessing import LabelEncoder
import os
import pickle
# 1. Chargement des donn√©es
cols_to_load = [
    'TUACTDUR24',    # Dur√©e de l'activit√©
    'ACTIVITY_NAME', # Nom de l'activit√©
    'TUSTARTTIM',    # Heure de d√©but (format HH:MM:SS)
    'TUDIARYDAY'     # Jour de la semaine
]
df = pd.read_csv("../Data/raw/atus_full_selected.csv", usecols=cols_to_load)
# 2. Nettoyage des donn√©es
df = df.dropna()
df = df.reset_index(drop=True)
# 3. Nouvelle fonction de conversion du temps
def time_to_minutes(t):
    """Convertit HH:MM:SS en minutes depuis minuit"""
    try:
        hh, mm, ss = map(int, t.split(':'))
        return hh * 60 + mm
    except:
        return 0  # Valeur par d√©faut si conversion √©choue

# Application de la conversion
df['START_MINUTES'] = df['TUSTARTTIM'].apply(time_to_minutes)

# 4. V√©rification des conversions
print("Exemples de conversion:")
print(df[['TUSTARTTIM', 'START_MINUTES']].head())

# 5. Encodage et autres transformations
activity_encoder = LabelEncoder()
df['ACTIVITY_CODE'] = activity_encoder.fit_transform(df['ACTIVITY_NAME'])
df['DAY_OF_WEEK'] = df['TUDIARYDAY'] - 1  # 0=dimanche, 6=samedi
df['IS_WEEKEND'] = (df['DAY_OF_WEEK'] >= 5).astype(int)

# 6. S√©lection finale des colonnes
final_columns = [
    'ACTIVITY_CODE',
    'TUACTDUR24',
    'START_MINUTES',
    'DAY_OF_WEEK',
    'IS_WEEKEND'
]
final_df = df[final_columns]
# 7. Sauvegarde
os.makedirs("../Data/processed", exist_ok=True)
final_df.to_csv("../Data/processed/cleaned_data.csv", index=False)
with open("../Data/processed/activity_encoder.pkl", "wb") as f:
    pickle.dump(activity_encoder, f)

le voila mon code pour le fichiers 3_dqn_training.ipynb:
import numpy as np
import pandas as pd
import tensorflow as tf
from collections import deque
import random
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import sys
# Ajouter le chemin du dossier parent (si besoin d'importer ScheduleEnv)
parent_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))
sys.path.append(parent_dir)
from environment.schedule_env import ScheduleEnv
# 1. Chargement des donn√©es
df = pd.read_csv("../Data/processed/cleaned_data.csv")

# 2. Initialiser l'environnement
env = ScheduleEnv(data_path="../Data/processed/cleaned_data.csv")
# Calculer la taille de l'√©tat
n_activities = len(env.activity_types)
state_size = env.n_time_slots * n_activities + env.days_of_week + 1  # schedule + day_of_week + time_remaining
action_size = env.action_space.nvec[0] * env.action_space.nvec[1]  # Nombre total d'actions possibles

print(f"\n‚úÖ Environnement cr√©√© avec {action_size} actions possibles")
# 3. Param√®tres du DQN
memory = deque(maxlen=2000)
batch_size = 32
gamma = 0.95
epsilon = 1.0
epsilon_min = 0.01
epsilon_decay = 0.995
# 4. Cr√©ation du mod√®le DQN
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, input_dim=state_size, activation='relu'),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(action_size, activation='linear')
])
model.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(0.001))
# Cr√©ation du mod√®le cible
target_model = tf.keras.models.clone_model(model)
target_model.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(0.001))
target_model.set_weights(model.get_weights())

# 5. Fonction pour mettre √† jour les graphiques
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plt.ion()
def update_plots(rewards, mean_rewards, epsilons, losses):
    ax1.clear()
    ax2.clear()
    
    ax1.plot(rewards, label='R√©compense par √©pisode', alpha=0.4)
    ax1.plot(mean_rewards, label='Moyenne glissante (20)', color='red')
    ax1.set_title('√âvolution des r√©compenses')
    ax1.set_xlabel('√âpisode')
    ax1.set_ylabel('R√©compense')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(epsilons, label='Epsilon', color='green')
    if losses:
        ax2.plot(losses, label='Perte (Loss)', color='orange')
    ax2.set_title("√âvolution de l'epsilon et des pertes")
    ax2.set_xlabel("√âpisode")
    ax2.legend()
    ax2.grid(True)

    plt.tight_layout()
    plt.draw()
    plt.pause(0.001)

# 6. Entra√Ænement du DQN
def train_dqn(episodes=300):
    global epsilon
    rewards_history = []
    epsilons = []
    mean_rewards = []
    loss_history = []

    progress_bar = tqdm(range(episodes), desc="üîÅ Entra√Ænement DQN", unit="episode")

    for episode in progress_bar:
        state = env.reset()
        state_flat = np.concatenate([state['schedule'].flatten(), state['day_of_week'], state['time_remaining']])
        state = np.reshape(state_flat, [1, state_size])
        total_reward = 0
        done = False
        episode_loss = []

        while not done:
            if np.random.rand() <= epsilon:
                action = env.action_space.sample()
                action_idx = action[0] * env.n_time_slots + action[1]
            else:
                q_values = model.predict(state, verbose=0)[0]
                action_idx = np.argmax(q_values)
                action = np.array([action_idx // env.n_time_slots, action_idx % env.n_time_slots])

            next_state, reward, done, _ = env.step(action)
            next_state_flat = np.concatenate([
                next_state['schedule'].flatten(), 
                next_state['day_of_week'], 
                next_state['time_remaining']
            ])
            next_state = np.reshape(next_state_flat, [1, state_size])

            memory.append((state, action_idx, reward, next_state, done))
            state = next_state
            total_reward += reward

            if len(memory) >= batch_size:
                minibatch = random.sample(memory, batch_size)
                states = np.array([x[0][0] for x in minibatch])
                actions = np.array([x[1] for x in minibatch])
                rewards_batch = np.array([x[2] for x in minibatch])
                next_states = np.array([x[3][0] for x in minibatch])
                dones = np.array([x[4] for x in minibatch])

                targets = model.predict(states, verbose=0)
                next_q_values = target_model.predict(next_states, verbose=0)

                for i in range(batch_size):
                    if dones[i]:
                        targets[i][actions[i]] = rewards_batch[i]
                    else:
                        targets[i][actions[i]] = rewards_batch[i] + gamma * np.max(next_q_values[i])

                history = model.fit(states, targets, epochs=1, verbose=0)
                episode_loss.append(history.history['loss'][0])

        if episode % 10 == 0:
            target_model.set_weights(model.get_weights())

        epsilon = max(epsilon_min, epsilon * epsilon_decay)
        rewards_history.append(total_reward)
        epsilons.append(epsilon)
        loss_history.append(np.mean(episode_loss) if episode_loss else 0)

        window_size = 20
        if episode >= window_size:
            mean_rewards.append(np.mean(rewards_history[-window_size:]))
        else:
            mean_rewards.append(np.mean(rewards_history))

        progress_bar.set_postfix({
            'Reward': f"{total_reward:.1f}",
            'Epsilon': f"{epsilon:.2f}",
            'AvgReward': f"{mean_rewards[-1]:.1f}",
            'Loss': f"{loss_history[-1]:.4f}" if episode_loss else "N/A"
        })

        if episode % 10 == 0:
            update_plots(rewards_history, mean_rewards, epsilons, loss_history)

    plt.ioff()
    plt.show()
    return rewards_history, mean_rewards, loss_history

# 7. Lancer l'entra√Ænement
print("\nüöÄ D√©but de l'entra√Ænement...")
rewards, avg_rewards, losses = train_dqn(episodes=300)

# 8. Sauvegarde du mod√®le
os.makedirs("../models", exist_ok=True)
model.save("../models/dqn_schedule_model.h5")
plt.figure(figsize=(10, 4))
plt.plot(rewards, label="R√©compense par √©pisode", alpha=0.4)
plt.plot(avg_rewards, label="R√©compense moyenne (20 √©pisodes)", color='red')
plt.title("√âvolution des R√©compenses")
plt.xlabel("√âpisode")
plt.ylabel("R√©compense")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 4))
plt.plot(losses, label="Perte moyenne", color='orange')
plt.title("√âvolution de la Perte pendant l'Entra√Ænement")
plt.xlabel("√âpisode")
plt.ylabel("Loss")
plt.grid(True)
plt.show()
fig, axs = plt.subplots(3, 1, figsize=(10, 12))

# Reward
axs[0].plot(rewards, label='R√©compense', alpha=0.4)
axs[0].plot(avg_rewards, label='Moyenne (20)', color='red')
axs[0].set_title("R√©compense par √©pisode")
axs[0].set_ylabel("Reward")
axs[0].legend()
axs[0].grid(True)

# Epsilon
axs[1].plot(epsilons, label='Epsilon', color='green')
axs[1].set_title("Valeur de Epsilon")
axs[1].set_ylabel("Epsilon")
axs[1].grid(True)

# Loss
axs[2].plot(losses, label='Perte', color='orange')
axs[2].set_title("Perte moyenne par √©pisode")
axs[2].set_xlabel("√âpisodes")
axs[2].set_ylabel("Loss")
axs[2].grid(True)

plt.tight_layout()
plt.show()

errur:
üìÖ Assistant Personnel de Gestion du Temps
Optimisez votre planning quotidien avec l'intelligence artificielle
Erreur lors du chargement du mod√®le: Could not locate function 'mse'. Make sure custom classes are decorated with @keras.saving.register_keras_serializable(). Full object config: {'module': 'keras.metrics', 'class_name': 'function', 'config': 'mse', 'registered_name': 'mse'}

Le mod√®le DQN n'a pas pu √™tre charg√©. Veuillez v√©rifier le fichier mod√®le.