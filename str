le voila mon projet :
titre :Assistant Personnel pour la Gestion du Temps
algorithme :Deep Q-Network
environnement/Donées : Données d'agenda personnel et historiques d'activités
methodes a utiliser : - Analyse des habitudes et préférences de l'utilisateur
- Application de DQN pour suggérer des plannings optimaux
- Évaluation basée sur l'amélioration de la productivité et la satisfaction de l'utilisateur
le voila mon structure :
📁 Optimisation-de-plannings-avec-DQN/
├── 📁 Data/                  # Données du projet
│   ├── 📁 Processed/        # Données prétraitées
│   │   ├── activity_encoder.pkl
│   │   └── cleaned_data.csv
│   └── 📁 raw/              # Données brutes
│       └── atus_full_selected.csv
├── 📁 environment/          # Environnement RL personnalisé
│   ├── 📄 schedule_env.py  # Implémentation de l'environnement Gym
├── 📁 models/              # Modèles entraînés
│   ├── dqn_final.h5
│   └── dqn_schedule_model.h5
├── 📁 notebooks/           # Notebooks Jupyter
│   ├── 2_data_preprocessing.ipynb  # Prétraitement des données
│   └── 3_dqn_training.ipynb       # Entraînement du DQN
└── 📁 ui/                  # Interface utilisateur
    └── 📄 app.py          # Application Streamlit

le voila mon code pour le fichiers schedule_env.py
"""
Environnement de planification pour l'Assistant Personnel de Gestion du Temps
Utilise un format compatible avec OpenAI Gym pour l'apprentissage par renforcement
"""
import numpy as np
import pandas as pd
import gym
from gym import spaces
from datetime import datetime, timedelta
import os

class ScheduleEnv(gym.Env):
    """
    Environnement de simulation pour la planification d'agenda personnel
    utilisant le format OpenAI Gym pour l'apprentissage par renforcement.
    """
    
    metadata = {'render.modes': ['human']}
    
    def __init__(self, data_path=None, user_id=None, n_time_slots=24, max_activities=10):
        super(ScheduleEnv, self).__init__()
        
        # Paramètres de l'environnement
        self.n_time_slots = n_time_slots  # 24 créneaux horaires (un par heure)
        self.max_activities = max_activities  # Nombre maximum d'activités à planifier
        self.days_of_week = 7  # Jour de la semaine (1-7)
        self.activity_types = None  # Sera défini lors du chargement des données
        
        # Charger et préprocesser les données
        self.load_user_data(data_path, user_id)
        
        # Définir l'espace d'actions : 
        # Pour chaque activité, on peut la planifier à n'importe quel créneau horaire
        # Actions: (activité_id, créneau_horaire)
        self.action_space = spaces.MultiDiscrete([
            len(self.activity_types), 
            self.n_time_slots
        ])
        
        # Définir l'espace d'observation
        # État: matrice [n_time_slots x n_activity_types] + vecteur jour de la semaine (one-hot)
        self.observation_space = spaces.Dict({
            'schedule': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.n_time_slots, len(self.activity_types)), 
                dtype=np.float32
            ),
            'day_of_week': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.days_of_week,), 
                dtype=np.float32
            ),
            'time_remaining': spaces.Box(
                low=0, 
                high=self.n_time_slots, 
                shape=(1,), 
                dtype=np.float32
            )
        })
        
        # État actuel de l'environnement
        self.current_schedule = None
        self.current_day = None
        self.available_time = None
        self.scheduled_activities = None
        
        # Historique des activités pour l'apprentissage des préférences utilisateur
        self.activity_history = None
        
        # Reset pour initialiser l'environnement
        self.reset()
    
    def load_user_data(self, data_path, user_id=None):
        """
        Charge les données d'activités d'un utilisateur spécifique ou d'un ensemble d'utilisateurs.
        Ne conserve que les colonnes essentielles pour le projet.
        """
        if data_path is None:
            # Créer des données synthétiques pour les tests
            self._create_synthetic_data()
            return
        
        try:
            # Charger les données
            data = pd.read_csv(data_path)
            
            # Filtrer uniquement les colonnes essentielles
            essential_cols = ['TUCASEID', 'TUACTIVITY_N', 'TUACTDUR24', 
                             'TUSTARTTIM', 'ACTIVITY_NAME', 'TUDIARYDAY']
            data = data[essential_cols]
            
            # Filtrer pour un utilisateur spécifique si fourni
            if user_id:
                data = data[data['TUCASEID'] == user_id]
            
            # Extraire les types d'activités uniques
            self.activity_types = data['ACTIVITY_NAME'].unique()
            
            # Convertir les heures de début en format numérique (minutes depuis minuit)
            data['start_time_minutes'] = data['TUSTARTTIM'].apply(self._convert_time_to_minutes)
            
            # Calculer les heures de fin
            data['end_time_minutes'] = data['start_time_minutes'] + data['TUACTDUR24']
            
            # Stocker les données traitées
            self.user_data = data
            
            # Calculer les statistiques des activités pour l'apprentissage des préférences
            self._compute_activity_statistics()
            
        except Exception as e:
            print(f"Erreur lors du chargement des données: {str(e)}")
            # Créer des données synthétiques en cas d'erreur
            self._create_synthetic_data()
    
    def _convert_time_to_minutes(self, time_str):
        """Convertit une chaîne de temps HH:MM en minutes depuis minuit."""
        try:
            hours, minutes = map(int, time_str.split(':'))
            return hours * 60 + minutes
        except:
            # Imputer la moyenne des heures pour l'activité si disponible
            return 8 * 60  # Fallback: 8h du matin
    
    def _create_synthetic_data(self):
        """Crée des données synthétiques pour les tests."""
        # Définir des types d'activités de base
        self.activity_types = np.array([
            'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
            'Sommeil', 'Tâches ménagères', 'Courses', 'Socialisation', 'Apprentissage'
        ])
        
        # Créer un dataframe avec des données synthétiques
        n_samples = 100
        synthetic_data = {
            'TUCASEID': np.ones(n_samples),
            'TUACTIVITY_N': np.arange(n_samples),
            'ACTIVITY_NAME': np.random.choice(self.activity_types, n_samples),
            'TUACTDUR24': np.random.randint(15, 240, n_samples),  # 15min à 4h
            'start_time_minutes': np.random.randint(0, 24*60, n_samples),
            'TUDIARYDAY': np.random.randint(1, 8, n_samples)  # 1-7 (lundi-dimanche)
        }
        
        # Calculer les heures de fin
        synthetic_data['end_time_minutes'] = synthetic_data['start_time_minutes'] + synthetic_data['TUACTDUR24']
        
        # Convertir en dataframe
        self.user_data = pd.DataFrame(synthetic_data)
        
        # Calculer les statistiques des activités
        self._compute_activity_statistics()
    
    def _compute_activity_statistics(self):
        """Calcule les statistiques des activités pour l'apprentissage des préférences."""
        # Grouper par type d'activité et jour de la semaine
        grouped = self.user_data.groupby(['ACTIVITY_NAME', 'TUDIARYDAY'])
        
        # Calculer la durée moyenne par activité et par jour
        self.avg_duration = grouped['TUACTDUR24'].mean().reset_index()
        
        # Calculer l'heure de début moyenne par activité et par jour
        self.avg_start_time = grouped['start_time_minutes'].mean().reset_index()
        
        # Calculer la fréquence des activités par jour
        self.activity_frequency = grouped.size().reset_index(name='frequency')
    
    def reset(self):
        """Réinitialise l'environnement et retourne l'état initial."""
        # Choisir un jour aléatoire de la semaine (1-7)
        self.current_day = np.random.randint(1, 8)
        
        # Initialiser un agenda vide
        self.current_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Initialiser le temps disponible (24 heures = 24 créneaux)
        self.available_time = self.n_time_slots
        
        # Initialiser la liste des activités planifiées
        self.scheduled_activities = []
        
        # Créer un vecteur one-hot pour le jour de la semaine
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1  # -1 car l'indexation commence à 0
        
        # Retourner l'état initial
        return {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
    
    def step(self, action):
        """
        Exécute une action dans l'environnement et retourne le nouvel état,
        la récompense, le statut de fin et des informations supplémentaires.
        
        Action: (activité_id, créneau_horaire)
        """
        activity_id, time_slot = action
        activity_name = self.activity_types[activity_id]
        
        # Vérifier si le créneau horaire est disponible
        if self.current_schedule[time_slot].sum() > 0:
            reward = -1.0  # Pénalité pour conflit horaire
            done = False
            info = {'status': 'conflict', 'activity': activity_name, 'time_slot': time_slot}
        else:
            # Planifier l'activité
            self.current_schedule[time_slot, activity_id] = 1
            self.available_time -= 1
            self.scheduled_activities.append((activity_name, time_slot))
            
            # Calculer la récompense basée sur les préférences utilisateur
            reward = self._compute_reward(activity_name, time_slot)
            
            # Vérifier si toutes les activités ont été planifiées ou si le temps est écoulé
            done = len(self.scheduled_activities) >= self.max_activities or self.available_time <= 0
            
            info = {'status': 'scheduled', 'activity': activity_name, 'time_slot': time_slot}
        
        # Construire le nouvel état
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1
        
        state = {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
        
        return state, reward, done, info
    
    def _compute_reward(self, activity_name, time_slot):
        """
        Calcule la récompense pour une activité planifiée à un créneau horaire spécifique,
        basé sur les préférences historiques de l'utilisateur.
        """
        # Convertir le créneau horaire en minutes (1 créneau = 1 heure = 60 minutes)
        scheduled_time = time_slot * 60
        
        # Trouver les statistiques pour cette activité et ce jour de la semaine
        act_stats = self.avg_start_time[
            (self.avg_start_time['ACTIVITY_NAME'] == activity_name) & 
            (self.avg_start_time['TUDIARYDAY'] == self.current_day)
        ]
        
        if not act_stats.empty:
            # Calculer la différence entre l'heure planifiée et l'heure préférée (en minutes)
            preferred_time = act_stats['start_time_minutes'].values[0]
            time_diff = abs(scheduled_time - preferred_time)
            
            # La récompense diminue avec l'écart par rapport à l'heure préférée
            # Normaliser pour que la récompense soit entre 0 et 1
            time_reward = max(0, 1 - (time_diff / (12 * 60)))  # max 12h de différence
        else:
            # Si nous n'avons pas d'information sur cette activité pour ce jour
            time_reward = 0.5  # Récompense neutre
        
        # Bonus pour une planification cohérente (activités similaires regroupées)
        coherence_reward = 0
        if len(self.scheduled_activities) > 0:
            for prev_activity, prev_slot in self.scheduled_activities:
                # Récompense pour les activités similaires regroupées
                if prev_activity == activity_name and abs(prev_slot - time_slot) <= 1:
                    coherence_reward += 0.2
                # Pénalité pour les activités qui devraient être espacées
                elif prev_activity == activity_name and abs(prev_slot - time_slot) < 3:
                    coherence_reward -= 0.1
        
        # La récompense finale est une combinaison de récompenses basées sur le temps et la cohérence
        reward = time_reward + coherence_reward
        
        return reward
    
    def render(self, mode='human'):
        """Affiche l'état actuel de l'environnement pour le débogage."""
        if mode != 'human':
            return
        
        print("\n===== ÉTAT ACTUEL DE L'AGENDA =====")
        print(f"Jour de la semaine: {self.current_day}")
        print(f"Temps restant: {self.available_time} créneaux")
        print("\nActivités planifiées:")
        
        for i, (activity, time_slot) in enumerate(self.scheduled_activities):
            print(f"{i+1}. {activity} à {time_slot}:00")
        
        print("\nGrille horaire:")
        for slot in range(self.n_time_slots):
            activities = [self.activity_types[i] for i in range(len(self.activity_types)) 
                         if self.current_schedule[slot, i] > 0]
            print(f"{slot}:00 - {activities if activities else 'Libre'}")
        
        print("====================================\n")
    
    def close(self):
        """Libère les ressources."""
        pass

    def get_optimal_schedule(self):
        """
        Génère un emploi du temps optimal basé sur les préférences utilisateur.
        Utilisé pour comparer les performances du modèle DQN.
        """
        # Créer un agenda vide
        optimal_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Filtrer les activités pour le jour actuel
        day_activities = self.avg_start_time[self.avg_start_time['TUDIARYDAY'] == self.current_day]
        
        # Trier par fréquence (priorité aux activités les plus fréquentes)
        day_activities = day_activities.merge(self.activity_frequency, 
                                          on=['ACTIVITY_NAME', 'TUDIARYDAY'])
        day_activities = day_activities.sort_values('frequency', ascending=False)
        
        # Planifier les activités à leur heure préférée
        for _, row in day_activities.iterrows():
            activity_name = row['ACTIVITY_NAME']
            preferred_time_minutes = row['start_time_minutes']
            
            # Convertir en créneau horaire (arrondi à l'heure la plus proche)
            preferred_slot = int(round(preferred_time_minutes / 60)) % self.n_time_slots
            
            # Vérifier si le créneau est disponible
            if optimal_schedule[preferred_slot].sum() == 0:
                # Trouver l'index de l'activité
                activity_idx = np.where(self.activity_types == activity_name)[0][0]
                
                # Planifier l'activité
                optimal_schedule[preferred_slot, activity_idx] = 1
            else:
                # Chercher le créneau disponible le plus proche
                for offset in range(1, self.n_time_slots // 2):
                    # Essayer le créneau avant
                    before_slot = (preferred_slot - offset) % self.n_time_slots
                    if optimal_schedule[before_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[before_slot, activity_idx] = 1
                        break
                    
                    # Essayer le créneau après
                    after_slot = (preferred_slot + offset) % self.n_time_slots
                    if optimal_schedule[after_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[after_slot, activity_idx] = 1
                        break
        
        return optimal_schedule
le voila mon code pour le fichiers app.py
"""
Application Streamlit pour l'Assistant Personnel de Gestion du Temps
Utilise un modèle DQN pour optimiser les plannings personnels des utilisateurs
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow.keras.models import load_model
import sys
import os
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path

# Ajouter le répertoire parent au chemin pour importer les modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from environment.schedule_env import ScheduleEnv

# Configuration de la page
st.set_page_config(
    page_title="Assistant Personnel de Gestion du Temps",
    page_icon="📅",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Chemins de fichiers
MODEL_PATH = '../models/dqn_schedule_model.h5'
DATA_PATH = '../Data/processed/cleaned_data.csv'
DEFAULT_ACTIVITIES = [
    'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
    'Sommeil', 'Tâches ménagères', 'Courses', 'Socialisation', 'Apprentissage'
]
ACTIVITY_COLORS = {
    'Travail': '#FF6B6B',
    'Repas': '#4ECDC4',
    'Transport': '#FFD166',
    'Loisirs': '#6B5B95',
    'Sport': '#88D8B0',
    'Sommeil': '#5D535E',
    'Tâches ménagères': '#F7B801',
    'Courses': '#F18701',
    'Socialisation': '#7BDFF2',
    'Apprentissage': '#B2DBBF'
}
# Pour toute autre activité, utiliser une couleur par défaut
DEFAULT_COLOR = '#CCCCCC'

# Fonction pour charger le modèle
@st.cache_resource
def load_dqn_model():
    """Charge le modèle DQN pré-entraîné"""
    try:
        model = load_model(MODEL_PATH)
        return model
    except Exception as e:
        st.error(f"Erreur lors du chargement du modèle: {str(e)}")
        return None

# Fonction pour charger les données
@st.cache_data
def load_data():
    """Charge les données prétraitées"""
    try:
        data = pd.read_csv(DATA_PATH)
        return data
    except Exception as e:
        st.warning(f"Erreur lors du chargement des données: {str(e)}")
        st.info("Utilisation de données par défaut")
        return None

# Créer un environnement Gym pour l'optimisation de planning
def create_environment(data=None, user_activities=None):
    """Crée l'environnement de simulation pour l'optimisation de planning"""
    if user_activities is None:
        user_activities = DEFAULT_ACTIVITIES
    
    env = ScheduleEnv(data_path=DATA_PATH if data is not None else None)
    
    # Si l'utilisateur a fourni des activités personnalisées, les utiliser
    if user_activities:
        env.activity_types = np.array(user_activities)
    
    return env

# Fonction pour générer un planning optimisé avec DQN
def generate_optimized_schedule(env, model, user_constraints=None, day_of_week=None):
    """
    Génère un planning optimisé en utilisant le modèle DQN
    
    Args:
        env: Environnement de simulation
        model: Modèle DQN pré-entraîné
        user_constraints: Dictionnaire de contraintes utilisateur
        day_of_week: Jour de la semaine spécifique (1-7, lundi-dimanche)
        
    Returns:
        schedule: Planning généré (matrice)
        activities: Liste des activités planifiées (avec heures)
        rewards: Récompenses obtenues
    """
    # Reset de l'environnement
    state = env.reset()
    
    # Si un jour spécifique est fourni, le définir manuellement
    if day_of_week is not None:
        env.current_day = day_of_week
        # Recréer le vecteur one-hot pour le jour
        day_of_week_vector = np.zeros(env.days_of_week)
        day_of_week_vector[env.current_day - 1] = 1
        state['day_of_week'] = day_of_week_vector
    
    # Appliquer les contraintes utilisateur si disponibles
    if user_constraints:
        # Exemple: bloquer certains créneaux horaires ou définir des activités obligatoires
        for activity, time_slots in user_constraints.items():
            if activity in env.activity_types:
                activity_idx = np.where(env.activity_types == activity)[0][0]
                for slot in time_slots:
                    if 0 <= slot < env.n_time_slots:
                        env.current_schedule[slot, activity_idx] = 1
                        env.available_time -= 1
    
    done = False
    total_reward = 0
    activities_planned = []
    
    # Simuler les actions du modèle DQN
    while not done and env.available_time > 0:
        # Préparer l'état pour la prédiction
        schedule_flat = state['schedule'].flatten()
        day_of_week = state['day_of_week']
        time_remaining = state['time_remaining']
        state_tensor = np.concatenate([schedule_flat, day_of_week, time_remaining])
        state_tensor = np.expand_dims(state_tensor, 0)
        
        # Prédire l'action avec le modèle
        act_values = model.predict(state_tensor, verbose=0)[0]
        
        # Convertir l'index plat en (activité, créneau)
        n_activities = len(env.activity_types)
        action_idx = np.argmax(act_values)
        activity_id = action_idx // env.n_time_slots
        time_slot = action_idx % env.n_time_slots
        action = np.array([activity_id, time_slot])
        
        # Vérifier si le créneau est déjà occupé
        while env.current_schedule[action[1]].sum() > 0:
            # Masquer cette action et trouver la prochaine meilleure
            act_values[action_idx] = -np.inf
            action_idx = np.argmax(act_values)
            activity_id = action_idx // env.n_time_slots
            time_slot = action_idx % env.n_time_slots
            action = np.array([activity_id, time_slot])
            
            # Si toutes les actions sont masquées, terminer
            if np.all(act_values == -np.inf):
                done = True
                break
        
        if not done:
            # Exécuter l'action sélectionnée
            next_state, reward, done, info = env.step(action)
            
            # Mettre à jour l'état et la récompense
            state = next_state
            total_reward += reward
            
            # Enregistrer l'activité planifiée
            activity_name = env.activity_types[action[0]]
            time_slot = action[1]
            activities_planned.append((activity_name, time_slot, reward))
    
    return env.current_schedule, activities_planned, total_reward

# Fonction pour visualiser le planning avec Plotly
def visualize_schedule_plotly(schedule, activities, activity_types):
    """Crée une visualisation interactive du planning avec Plotly"""
    # Créer un dataframe pour la visualisation
    schedule_data = []
    
    for slot in range(schedule.shape[0]):
        for activity_idx in range(schedule.shape[1]):
            if schedule[slot, activity_idx] > 0:
                activity = activity_types[activity_idx]
                schedule_data.append({
                    'Heure': f"{slot:02d}:00",
                    'Activité': activity,
                    'Valeur': 1,
                    'Couleur': ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
                })
    
    if not schedule_data:
        return go.Figure()
    
    schedule_df = pd.DataFrame(schedule_data)
    
    # Créer la visualisation avec Plotly
    fig = px.timeline(
        schedule_df, 
        x_start="Heure", 
        y="Activité", 
        color="Activité",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Journalier Optimisé"
    )
    
    # Personnaliser l'apparence
    fig.update_layout(
        xaxis_title="Heure de la journée",
        yaxis_title="Activité",
        height=600,
        showlegend=True
    )
    
    return fig

# Fonction pour créer un calendrier hebdomadaire
def create_weekly_calendar(daily_schedules, activity_types):
    """Crée un calendrier hebdomadaire à partir des plannings quotidiens"""
    days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']
    calendar_data = []
    
    for day_idx, day_name in enumerate(days):
        if day_idx < len(daily_schedules):
            schedule = daily_schedules[day_idx]
            
            for slot in range(schedule.shape[0]):
                for activity_idx in range(schedule.shape[1]):
                    if schedule[slot, activity_idx] > 0:
                        activity = activity_types[activity_idx]
                        calendar_data.append({
                            'Jour': day_name,
                            'Heure': f"{slot:02d}:00",
                            'Activité': activity,
                            'Couleur': ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
                        })
    
    if not calendar_data:
        return go.Figure()
    
    calendar_df = pd.DataFrame(calendar_data)
    
    # Créer la visualisation avec Plotly
    fig = px.timeline(
        calendar_df, 
        x="Heure", 
        y="Jour", 
        color="Activité",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Hebdomadaire Optimisé"
    )
    
    # Personnaliser l'apparence
    fig.update_layout(
        xaxis_title="Heure de la journée",
        yaxis_title="Jour de la semaine",
        height=600,
        showlegend=True
    )
    
    return fig

# Fonction pour calculer des statistiques sur le planning
def calculate_schedule_stats(activities):
    """Calcule des statistiques sur le planning généré"""
    if not activities:
        return {}
    
    # Compter les activités par type
    activity_counts = {}
    for activity, time_slot, reward in activities:
        if activity in activity_counts:
            activity_counts[activity] += 1
        else:
            activity_counts[activity] = 1
    
    # Calculer les heures les plus productives
    rewards_by_hour = {}
    for activity, time_slot, reward in activities:
        if time_slot in rewards_by_hour:
            rewards_by_hour[time_slot] += reward
        else:
            rewards_by_hour[time_slot] = reward
    
    # Trouver l'heure la plus productive
    most_productive_hour = max(rewards_by_hour, key=rewards_by_hour.get) if rewards_by_hour else None
    
    return {
        'activity_counts': activity_counts,
        'rewards_by_hour': rewards_by_hour,
        'most_productive_hour': most_productive_hour
    }

# Interface utilisateur avec Streamlit
def main():
    # Titre de l'application
    st.title("📅 Assistant Personnel de Gestion du Temps")
    st.subheader("Optimisez votre planning quotidien avec l'intelligence artificielle")
    
    # Chargement du modèle et des données
    model = load_dqn_model()
    data = load_data()
    
    if model is None:
        st.error("Le modèle DQN n'a pas pu être chargé. Veuillez vérifier le fichier modèle.")
        return
    
    # Sidebar pour les paramètres
    st.sidebar.title("Paramètres")
    
    # Option pour choisir entre planning quotidien ou hebdomadaire
    planning_type = st.sidebar.radio(
        "Type de planning",
        ["📆 Planning quotidien", "🗓️ Planning hebdomadaire"]
    )
    
    # Option pour choisir le jour de la semaine
    day_options = {
        "Lundi": 1, "Mardi": 2, "Mercredi": 3, "Jeudi": 4, 
        "Vendredi": 5, "Samedi": 6, "Dimanche": 7
    }
    
    if planning_type == "📆 Planning quotidien":
        selected_day_name = st.sidebar.selectbox(
            "Jour de la semaine",
            list(day_options.keys())
        )
        selected_day = day_options[selected_day_name]
    else:
        selected_day = None
    
    # Paramètres personnalisés
    st.sidebar.subheader("Activités personnalisées")
    
    # Option pour utiliser les activités par défaut ou personnalisées
    use_default_activities = st.sidebar.checkbox("Utiliser les activités par défaut", value=True)
    
    if use_default_activities:
        activities = DEFAULT_ACTIVITIES
    else:
        # Champ texte pour entrer les activités personnalisées
        custom_activities_input = st.sidebar.text_area(
            "Entrez vos activités (une par ligne)",
            value="\n".join(DEFAULT_ACTIVITIES)
        )
        activities = [act.strip() for act in custom_activities_input.split("\n") if act.strip()]
    
    # Affichage des activités
    st.sidebar.subheader("Liste des activités")
    for i, activity in enumerate(activities):
        color = ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
        st.sidebar.markdown(
            f"<div style='background-color:{color}; padding:5px; border-radius:5px; margin:2px 0;'>"
            f"{i+1}. {activity}</div>",
            unsafe_allow_html=True
        )
    
    # Contraintes utilisateur
    st.sidebar.subheader("Contraintes (optionnel)")
    add_constraints = st.sidebar.checkbox("Ajouter des contraintes horaires")
    
    user_constraints = {}
    if add_constraints:
        # Interface pour ajouter des contraintes
        constraint_activity = st.sidebar.selectbox(
            "Activité",
            activities
        )
        
        constraint_time = st.sidebar.multiselect(
            "Horaires (obligatoires)",
            [f"{h:02d}:00" for h in range(24)]
        )
        
        if st.sidebar.button("Ajouter cette contrainte"):
            time_slots = [int(t.split(":")[0]) for t in constraint_time]
            if constraint_activity in user_constraints:
                user_constraints[constraint_activity].extend(time_slots)
            else:
                user_constraints[constraint_activity] = time_slots
    
    # Affichage des contraintes
    if user_constraints:
        st.sidebar.subheader("Contraintes ajoutées")
        for activity, slots in user_constraints.items():
            st.sidebar.write(f"{activity}: {', '.join([f'{s:02d}:00' for s in slots])}")
    
    # Bouton pour générer le planning
    if planning_type == "📆 Planning quotidien":
        generate_button = st.sidebar.button("Générer planning quotidien")
    else:
        generate_button = st.sidebar.button("Générer planning hebdomadaire")
    
    # Corps principal de l'application
    if generate_button:
        with st.spinner("Génération du planning en cours..."):
            # Créer l'environnement
            env = create_environment(data, activities)
            
            if planning_type == "📆 Planning quotidien":
                # Générer un planning quotidien
                schedule, activities_planned, total_reward = generate_optimized_schedule(
                    env, model, user_constraints, selected_day
                )
                
                # Afficher le planning
                st.subheader(f"Planning optimisé pour {selected_day_name}")
                
                # Visualisation du planning avec Plotly
                fig = visualize_schedule_plotly(schedule, activities_planned, env.activity_types)
                st.plotly_chart(fig, use_container_width=True)
                
                # Afficher les activités planifiées
                if activities_planned:
                    st.subheader("Détail des activités")
                    
                    activities_df = pd.DataFrame([(act, f"{slot:02d}:00", f"{reward:.2f}") 
                                                for act, slot, reward in activities_planned],
                                               columns=["Activité", "Heure", "Score"])
                    
                    st.dataframe(activities_df.sort_values(by="Heure"), use_container_width=True)
                    
                    # Calculer et afficher des statistiques
                    stats = calculate_schedule_stats(activities_planned)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("Distribution des activités")
                        if stats['activity_counts']:
                            fig = px.pie(
                                values=list(stats['activity_counts'].values()),
                                names=list(stats['activity_counts'].keys()),
                                title="Distribution des activités",
                                color=list(stats['activity_counts'].keys()),
                                color_discrete_map=ACTIVITY_COLORS
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with col2:
                        st.subheader("Productivité par heure")
                        if stats['rewards_by_hour']:
                            hours = [f"{h:02d}:00" for h in stats['rewards_by_hour'].keys()]
                            rewards = list(stats['rewards_by_hour'].values())
                            
                            fig = px.bar(
                                x=hours,
                                y=rewards,
                                title="Score de productivité par heure",
                                labels={'x': 'Heure', 'y': 'Score de productivité'}
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    # Afficher l'heure la plus productive
                    if stats['most_productive_hour'] is not None:
                        st.info(f"✨ Votre heure la plus productive est {stats['most_productive_hour']:02d}:00")
                
                # Qualité du planning
                st.subheader("Évaluation du planning")
                st.write(f"Score total du planning: {total_reward:.2f}")
                
                # Jauge de qualité
                quality = min(max(total_reward / 10, 0), 1)  # Normaliser entre 0 et 1
                
                gauge = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=quality * 100,
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': "Qualité du planning"},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 33], 'color': "red"},
                            {'range': [33, 66], 'color': "yellow"},
                            {'range': [66, 100], 'color': "green"}
                        ]
                    }
                ))
                
                st.plotly_chart(gauge, use_container_width=True)
                
                # Ajouter des recommandations
                st.subheader("Recommandations")
                
                if quality < 0.4:
                    st.warning("Votre planning pourrait être amélioré. Essayez d'ajouter plus de contraintes ou de modifier vos activités.")
                elif quality < 0.7:
                    st.info("Votre planning est bon, mais il pourrait encore être optimisé.")
                else:
                    st.success("Excellent planning ! Votre journée est optimisée pour une productivité maximale.")
            
            else:
                # Générer un planning hebdomadaire
                st.subheader("Planning hebdomadaire optimisé")
                
                daily_schedules = []
                all_activities_planned = []
                total_weekly_reward = 0
                
                # Générer un planning pour chaque jour de la semaine
                for day in range(1, 8):
                    day_schedule, day_activities, day_reward = generate_optimized_schedule(
                        env, model, user_constraints, day
                    )
                    daily_schedules.append(day_schedule)
                    all_activities_planned.extend([(act, slot, reward, day) for act, slot, reward in day_activities])
                    total_weekly_reward += day_reward
                
                # Visualiser le calendrier hebdomadaire
                fig = create_weekly_calendar(daily_schedules, env.activity_types)
                st.plotly_chart(fig, use_container_width=True)
                
                # Afficher les statistiques hebdomadaires
                st.subheader("Statistiques hebdomadaires")
                
                # Préparer les données pour les statistiques
                activities_by_day = {}
                for day_idx in range(7):
                    day_name = list(day_options.keys())[day_idx]
                    day_activities = [act for act, _, _, day in all_activities_planned if day == day_idx + 1]
                    activities_by_day[day_name] = len(day_activities)
                
                # Afficher la distribution des activités par jour
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Activités par jour")
                    fig = px.bar(
                        x=list(activities_by_day.keys()),
                        y=list(activities_by_day.values()),
                        title="Nombre d'activités par jour",
                        labels={'x': 'Jour', 'y': 'Nombre d\'activités'}
                    )
                    st.plotly_chart(fig, use_container_width=True)
                
                with col2:
                    st.subheader("Score hebdomadaire")
                    st.write(f"Score total de la semaine: {total_weekly_reward:.2f}")
                    
                    # Jauge de qualité hebdomadaire
                    quality = min(max(total_weekly_reward / 70, 0), 1)  # Normaliser entre 0 et 1
                    
                    gauge = go.Figure(go.Indicator(
                        mode="gauge+number",
                        value=quality * 100,
                        domain={'x': [0, 1], 'y': [0, 1]},
                        title={'text': "Qualité du planning hebdomadaire"},
                        gauge={
                            'axis': {'range': [0, 100]},
                            'bar': {'color': "darkblue"},
                            'steps': [
                                {'range': [0, 33], 'color': "red"},
                                {'range': [33, 66], 'color': "yellow"},
                                {'range': [66, 100], 'color': "green"}
                            ]
                        }
                    ))
                    
                    st.plotly_chart(gauge, use_container_width=True)
                
                # Afficher les activités les plus fréquentes
                activity_counts = {}
                for act, _, _, _ in all_activities_planned:
                    if act in activity_counts:
                        activity_counts[act] += 1
                    else:
                        activity_counts[act] = 1
                
                st.subheader("Répartition des activités sur la semaine")
                fig = px.pie(
                    values=list(activity_counts.values()),
                    names=list(activity_counts.keys()),
                    title="Distribution des activités sur la semaine",
                    color=list(activity_counts.keys()),
                    color_discrete_map=ACTIVITY_COLORS
                )
                st.plotly_chart(fig, use_container_width=True)
                
                # Téléchargement du planning
                st.subheader("Exporter le planning")
                
                # Créer un dataframe pour l'exportation
                export_data = []
                days = list(day_options.keys())
                
                for day_idx, day_name in enumerate(days):
                    day_activities = [(act, slot) for act, slot, _, day in all_activities_planned if day == day_idx + 1]
                    for activity, time_slot in day_activities:
                        export_data.append({
                            'Jour': day_name,
                            'Heure': f"{time_slot:02d}:00",
                            'Activité': activity
                        })
                
                export_df = pd.DataFrame(export_data)
                
                # Créer un fichier CSV pour l'exportation
                csv = export_df.to_csv(index=False)
                st.download_button(
                    label="Télécharger le planning (CSV)",
                    data=csv,
                    file_name=f"planning_hebdomadaire_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv"
                )
    
    else:
        # Afficher l'introduction de l'application
        st.write("""
        Bienvenue dans votre Assistant Personnel de Gestion du Temps ! Cette application utilise l'intelligence artificielle
        pour vous aider à optimiser votre emploi du temps quotidien ou hebdomadaire.
        
        ### 🧠 Comment ça marche ?
        
        Notre application utilise un algorithme d'apprentissage par renforcement appelé **Deep Q-Network (DQN)** pour analyser vos habitudes
        et préférences, puis générer un planning optimisé qui maximise votre productivité et votre satisfaction.
        
        ### 🚀 Fonctionnalités
        
        - **Planning quotidien**: Obtenez un emploi du temps optimisé pour une journée spécifique
        - **Planning hebdomadaire**: Visualisez un calendrier complet pour toute la semaine
        - **Activités personnalisées**: Définissez vos propres types d'activités
        - **Contraintes horaires**: Ajoutez des activités obligatoires à des heures précises
        - **Statistiques**: Analysez la qualité de votre planning et identifiez vos heures les plus productives
        
        ### 📊 Commencer
        
        Utilisez les options dans la barre latérale pour personnaliser votre planning, puis cliquez sur "Générer planning" pour voir les résultats.
        """)
        
        # Ajouter une image ou un schéma explicatif
        st.image("https://via.placeholder.com/800x400?text=Assistant+Personnel+de+Gestion+du+Temps", 
                 caption="Optimisez votre temps avec l'IA")

# Exécuter l'application
if __name__ == "__main__":
    main()
le voila mon code pour le fichiers 2_data_preprocessing.ipynb:
import pandas as pd
from sklearn.preprocessing import LabelEncoder
import os
import pickle
# 1. Chargement des données
cols_to_load = [
    'TUACTDUR24',    # Durée de l'activité
    'ACTIVITY_NAME', # Nom de l'activité
    'TUSTARTTIM',    # Heure de début (format HH:MM:SS)
    'TUDIARYDAY'     # Jour de la semaine
]
df = pd.read_csv("../Data/raw/atus_full_selected.csv", usecols=cols_to_load)
# 2. Nettoyage des données
df = df.dropna()
df = df.reset_index(drop=True)
# 3. Nouvelle fonction de conversion du temps
def time_to_minutes(t):
    """Convertit HH:MM:SS en minutes depuis minuit"""
    try:
        hh, mm, ss = map(int, t.split(':'))
        return hh * 60 + mm
    except:
        return 0  # Valeur par défaut si conversion échoue

# Application de la conversion
df['START_MINUTES'] = df['TUSTARTTIM'].apply(time_to_minutes)

# 4. Vérification des conversions
print("Exemples de conversion:")
print(df[['TUSTARTTIM', 'START_MINUTES']].head())

# 5. Encodage et autres transformations
activity_encoder = LabelEncoder()
df['ACTIVITY_CODE'] = activity_encoder.fit_transform(df['ACTIVITY_NAME'])
df['DAY_OF_WEEK'] = df['TUDIARYDAY'] - 1  # 0=dimanche, 6=samedi
df['IS_WEEKEND'] = (df['DAY_OF_WEEK'] >= 5).astype(int)

# 6. Sélection finale des colonnes
final_columns = [
    'ACTIVITY_CODE',
    'TUACTDUR24',
    'START_MINUTES',
    'DAY_OF_WEEK',
    'IS_WEEKEND'
]
final_df = df[final_columns]
# 7. Sauvegarde
os.makedirs("../Data/processed", exist_ok=True)
final_df.to_csv("../Data/processed/cleaned_data.csv", index=False)
with open("../Data/processed/activity_encoder.pkl", "wb") as f:
    pickle.dump(activity_encoder, f)

le voila mon code pour le fichiers 3_dqn_training.ipynb:
import numpy as np
import pandas as pd
import tensorflow as tf
from collections import deque
import random
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import sys
# Ajouter le chemin du dossier parent (si besoin d'importer ScheduleEnv)
parent_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))
sys.path.append(parent_dir)
from environment.schedule_env import ScheduleEnv
# 1. Chargement des données
df = pd.read_csv("../Data/processed/cleaned_data.csv")

# 2. Initialiser l'environnement
env = ScheduleEnv(data_path="../Data/processed/cleaned_data.csv")
# Calculer la taille de l'état
n_activities = len(env.activity_types)
state_size = env.n_time_slots * n_activities + env.days_of_week + 1  # schedule + day_of_week + time_remaining
action_size = env.action_space.nvec[0] * env.action_space.nvec[1]  # Nombre total d'actions possibles

print(f"\n✅ Environnement créé avec {action_size} actions possibles")
# 3. Paramètres du DQN
memory = deque(maxlen=2000)
batch_size = 32
gamma = 0.95
epsilon = 1.0
epsilon_min = 0.01
epsilon_decay = 0.995
# 4. Création du modèle DQN
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, input_dim=state_size, activation='relu'),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(action_size, activation='linear')
])
model.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(0.001))
# Création du modèle cible
target_model = tf.keras.models.clone_model(model)
target_model.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(0.001))
target_model.set_weights(model.get_weights())

# 5. Fonction pour mettre à jour les graphiques
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plt.ion()
def update_plots(rewards, mean_rewards, epsilons, losses):
    ax1.clear()
    ax2.clear()
    
    ax1.plot(rewards, label='Récompense par épisode', alpha=0.4)
    ax1.plot(mean_rewards, label='Moyenne glissante (20)', color='red')
    ax1.set_title('Évolution des récompenses')
    ax1.set_xlabel('Épisode')
    ax1.set_ylabel('Récompense')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(epsilons, label='Epsilon', color='green')
    if losses:
        ax2.plot(losses, label='Perte (Loss)', color='orange')
    ax2.set_title("Évolution de l'epsilon et des pertes")
    ax2.set_xlabel("Épisode")
    ax2.legend()
    ax2.grid(True)

    plt.tight_layout()
    plt.draw()
    plt.pause(0.001)

# 6. Entraînement du DQN
def train_dqn(episodes=300):
    global epsilon
    rewards_history = []
    epsilons = []
    mean_rewards = []
    loss_history = []

    progress_bar = tqdm(range(episodes), desc="🔁 Entraînement DQN", unit="episode")

    for episode in progress_bar:
        state = env.reset()
        state_flat = np.concatenate([state['schedule'].flatten(), state['day_of_week'], state['time_remaining']])
        state = np.reshape(state_flat, [1, state_size])
        total_reward = 0
        done = False
        episode_loss = []

        while not done:
            if np.random.rand() <= epsilon:
                action = env.action_space.sample()
                action_idx = action[0] * env.n_time_slots + action[1]
            else:
                q_values = model.predict(state, verbose=0)[0]
                action_idx = np.argmax(q_values)
                action = np.array([action_idx // env.n_time_slots, action_idx % env.n_time_slots])

            next_state, reward, done, _ = env.step(action)
            next_state_flat = np.concatenate([
                next_state['schedule'].flatten(), 
                next_state['day_of_week'], 
                next_state['time_remaining']
            ])
            next_state = np.reshape(next_state_flat, [1, state_size])

            memory.append((state, action_idx, reward, next_state, done))
            state = next_state
            total_reward += reward

            if len(memory) >= batch_size:
                minibatch = random.sample(memory, batch_size)
                states = np.array([x[0][0] for x in minibatch])
                actions = np.array([x[1] for x in minibatch])
                rewards_batch = np.array([x[2] for x in minibatch])
                next_states = np.array([x[3][0] for x in minibatch])
                dones = np.array([x[4] for x in minibatch])

                targets = model.predict(states, verbose=0)
                next_q_values = target_model.predict(next_states, verbose=0)

                for i in range(batch_size):
                    if dones[i]:
                        targets[i][actions[i]] = rewards_batch[i]
                    else:
                        targets[i][actions[i]] = rewards_batch[i] + gamma * np.max(next_q_values[i])

                history = model.fit(states, targets, epochs=1, verbose=0)
                episode_loss.append(history.history['loss'][0])

        if episode % 10 == 0:
            target_model.set_weights(model.get_weights())

        epsilon = max(epsilon_min, epsilon * epsilon_decay)
        rewards_history.append(total_reward)
        epsilons.append(epsilon)
        loss_history.append(np.mean(episode_loss) if episode_loss else 0)

        window_size = 20
        if episode >= window_size:
            mean_rewards.append(np.mean(rewards_history[-window_size:]))
        else:
            mean_rewards.append(np.mean(rewards_history))

        progress_bar.set_postfix({
            'Reward': f"{total_reward:.1f}",
            'Epsilon': f"{epsilon:.2f}",
            'AvgReward': f"{mean_rewards[-1]:.1f}",
            'Loss': f"{loss_history[-1]:.4f}" if episode_loss else "N/A"
        })

        if episode % 10 == 0:
            update_plots(rewards_history, mean_rewards, epsilons, loss_history)

    plt.ioff()
    plt.show()
    return rewards_history, mean_rewards, loss_history

# 7. Lancer l'entraînement
print("\n🚀 Début de l'entraînement...")
rewards, avg_rewards, losses = train_dqn(episodes=300)

# 8. Sauvegarde du modèle
os.makedirs("../models", exist_ok=True)
model.save("../models/dqn_schedule_model.h5")
plt.figure(figsize=(10, 4))
plt.plot(rewards, label="Récompense par épisode", alpha=0.4)
plt.plot(avg_rewards, label="Récompense moyenne (20 épisodes)", color='red')
plt.title("Évolution des Récompenses")
plt.xlabel("Épisode")
plt.ylabel("Récompense")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 4))
plt.plot(losses, label="Perte moyenne", color='orange')
plt.title("Évolution de la Perte pendant l'Entraînement")
plt.xlabel("Épisode")
plt.ylabel("Loss")
plt.grid(True)
plt.show()
fig, axs = plt.subplots(3, 1, figsize=(10, 12))

# Reward
axs[0].plot(rewards, label='Récompense', alpha=0.4)
axs[0].plot(avg_rewards, label='Moyenne (20)', color='red')
axs[0].set_title("Récompense par épisode")
axs[0].set_ylabel("Reward")
axs[0].legend()
axs[0].grid(True)

# Epsilon
axs[1].plot(epsilons, label='Epsilon', color='green')
axs[1].set_title("Valeur de Epsilon")
axs[1].set_ylabel("Epsilon")
axs[1].grid(True)

# Loss
axs[2].plot(losses, label='Perte', color='orange')
axs[2].set_title("Perte moyenne par épisode")
axs[2].set_xlabel("Épisodes")
axs[2].set_ylabel("Loss")
axs[2].grid(True)

plt.tight_layout()
plt.show()

errur:
📅 Assistant Personnel de Gestion du Temps
Optimisez votre planning quotidien avec l'intelligence artificielle
Erreur lors du chargement du modèle: Could not locate function 'mse'. Make sure custom classes are decorated with @keras.saving.register_keras_serializable(). Full object config: {'module': 'keras.metrics', 'class_name': 'function', 'config': 'mse', 'registered_name': 'mse'}

Le modèle DQN n'a pas pu être chargé. Veuillez vérifier le fichier modèle.