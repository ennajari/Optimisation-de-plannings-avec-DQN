le voila mon projet :
titre :Assistant Personnel pour la Gestion du Temps
algorithme :Deep Q-Network
environnement/Don√©es : Donn√©es d'agenda personnel et historiques d'activit√©s
methodes a utiliser : - Analyse des habitudes et pr√©f√©rences de l'utilisateur
- Application de DQN pour sugg√©rer des plannings optimaux
- √âvaluation bas√©e sur l'am√©lioration de la productivit√© et la satisfaction de l'utilisateur
le voila mon structure :
üìÅ Optimisation-de-plannings-avec-DQN/
‚îú‚îÄ‚îÄ üìÅ Data/                  # Donn√©es du projet
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Processed/        # Donn√©es pr√©trait√©es
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ activity_encoder.pkl
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cleaned_data.csv
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ raw/              # Donn√©es brutes
‚îÇ       ‚îî‚îÄ‚îÄ atus_full_selected.csv
‚îú‚îÄ‚îÄ üìÅ environment/          # Environnement RL personnalis√©
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ schedule_env.py  # Impl√©mentation de l'environnement Gym
‚îú‚îÄ‚îÄ üìÅ models/              # Mod√®les entra√Æn√©s
‚îÇ   ‚îú‚îÄ‚îÄ dqn_final.h5
‚îÇ   ‚îî‚îÄ‚îÄ dqn_schedule_model.h5
‚îú‚îÄ‚îÄ üìÅ notebooks/           # Notebooks Jupyter
‚îÇ   ‚îú‚îÄ‚îÄ 2_data_preprocessing.ipynb  # Pr√©traitement des donn√©es
‚îÇ   ‚îî‚îÄ‚îÄ 3_dqn_training.ipynb       # Entra√Ænement du DQN
‚îî‚îÄ‚îÄ üìÅ ui/                  # Interface utilisateur
    ‚îî‚îÄ‚îÄ üìÑ app.py          # Application Streamlit

le voila mon code pour le fichiers schedule_env.py
"""
Environnement de planification pour l'Assistant Personnel de Gestion du Temps
Utilise un format compatible avec OpenAI Gym pour l'apprentissage par renforcement
"""
import numpy as np
import pandas as pd
import gym
from gym import spaces
from datetime import datetime, timedelta
import os

class ScheduleEnv(gym.Env):
    """
    Environnement de simulation pour la planification d'agenda personnel
    utilisant le format OpenAI Gym pour l'apprentissage par renforcement.
    """
    
    metadata = {'render.modes': ['human']}
    
    def __init__(self, data_path=None, user_id=None, n_time_slots=24, max_activities=10):
        super(ScheduleEnv, self).__init__()
        
        # Param√®tres de l'environnement
        self.n_time_slots = n_time_slots  # 24 cr√©neaux horaires (un par heure)
        self.max_activities = max_activities  # Nombre maximum d'activit√©s √† planifier
        self.days_of_week = 7  # Jour de la semaine (1-7)
        self.activity_types = None  # Sera d√©fini lors du chargement des donn√©es
        
        # Charger et pr√©processer les donn√©es
        self.load_user_data(data_path, user_id)
        
        # D√©finir l'espace d'actions : 
        # Pour chaque activit√©, on peut la planifier √† n'importe quel cr√©neau horaire
        # Actions: (activit√©_id, cr√©neau_horaire)
        self.action_space = spaces.MultiDiscrete([
            len(self.activity_types), 
            self.n_time_slots
        ])
        
        # D√©finir l'espace d'observation
        # √âtat: matrice [n_time_slots x n_activity_types] + vecteur jour de la semaine (one-hot)
        self.observation_space = spaces.Dict({
            'schedule': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.n_time_slots, len(self.activity_types)), 
                dtype=np.float32
            ),
            'day_of_week': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.days_of_week,), 
                dtype=np.float32
            ),
            'time_remaining': spaces.Box(
                low=0, 
                high=self.n_time_slots, 
                shape=(1,), 
                dtype=np.float32
            )
        })
        
        # √âtat actuel de l'environnement
        self.current_schedule = None
        self.current_day = None
        self.available_time = None
        self.scheduled_activities = None
        
        # Historique des activit√©s pour l'apprentissage des pr√©f√©rences utilisateur
        self.activity_history = None
        
        # Reset pour initialiser l'environnement
        self.reset()
    
    def load_user_data(self, data_path, user_id=None):
        """
        Charge les donn√©es d'activit√©s d'un utilisateur sp√©cifique ou d'un ensemble d'utilisateurs.
        Ne conserve que les colonnes essentielles pour le projet.
        """
        if data_path is None:
            # Cr√©er des donn√©es synth√©tiques pour les tests
            self._create_synthetic_data()
            return
        
        try:
            # Charger les donn√©es
            data = pd.read_csv(data_path)
            
            # Filtrer uniquement les colonnes essentielles
            essential_cols = ['TUCASEID', 'TUACTIVITY_N', 'TUACTDUR24', 
                             'TUSTARTTIM', 'ACTIVITY_NAME', 'TUDIARYDAY']
            data = data[essential_cols]
            
            # Filtrer pour un utilisateur sp√©cifique si fourni
            if user_id:
                data = data[data['TUCASEID'] == user_id]
            
            # Extraire les types d'activit√©s uniques
            self.activity_types = data['ACTIVITY_NAME'].unique()
            
            # Convertir les heures de d√©but en format num√©rique (minutes depuis minuit)
            data['start_time_minutes'] = data['TUSTARTTIM'].apply(self._convert_time_to_minutes)
            
            # Calculer les heures de fin
            data['end_time_minutes'] = data['start_time_minutes'] + data['TUACTDUR24']
            
            # Stocker les donn√©es trait√©es
            self.user_data = data
            
            # Calculer les statistiques des activit√©s pour l'apprentissage des pr√©f√©rences
            self._compute_activity_statistics()
            
        except Exception as e:
            print(f"Erreur lors du chargement des donn√©es: {str(e)}")
            # Cr√©er des donn√©es synth√©tiques en cas d'erreur
            self._create_synthetic_data()
    
    def _convert_time_to_minutes(self, time_str):
        """Convertit une cha√Æne de temps HH:MM en minutes depuis minuit."""
        try:
            hours, minutes = map(int, time_str.split(':'))
            return hours * 60 + minutes
        except:
            # Imputer la moyenne des heures pour l'activit√© si disponible
            return 8 * 60  # Fallback: 8h du matin
    
    def _create_synthetic_data(self):
        """Cr√©e des donn√©es synth√©tiques pour les tests."""
        # D√©finir des types d'activit√©s de base
        self.activity_types = np.array([
            'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
            'Sommeil', 'T√¢ches m√©nag√®res', 'Courses', 'Socialisation', 'Apprentissage'
        ])
        
        # Cr√©er un dataframe avec des donn√©es synth√©tiques
        n_samples = 100
        synthetic_data = {
            'TUCASEID': np.ones(n_samples),
            'TUACTIVITY_N': np.arange(n_samples),
            'ACTIVITY_NAME': np.random.choice(self.activity_types, n_samples),
            'TUACTDUR24': np.random.randint(15, 240, n_samples),  # 15min √† 4h
            'start_time_minutes': np.random.randint(0, 24*60, n_samples),
            'TUDIARYDAY': np.random.randint(1, 8, n_samples)  # 1-7 (lundi-dimanche)
        }
        
        # Calculer les heures de fin
        synthetic_data['end_time_minutes'] = synthetic_data['start_time_minutes'] + synthetic_data['TUACTDUR24']
        
        # Convertir en dataframe
        self.user_data = pd.DataFrame(synthetic_data)
        
        # Calculer les statistiques des activit√©s
        self._compute_activity_statistics()
    
    def _compute_activity_statistics(self):
        """Calcule les statistiques des activit√©s pour l'apprentissage des pr√©f√©rences."""
        # Grouper par type d'activit√© et jour de la semaine
        grouped = self.user_data.groupby(['ACTIVITY_NAME', 'TUDIARYDAY'])
        
        # Calculer la dur√©e moyenne par activit√© et par jour
        self.avg_duration = grouped['TUACTDUR24'].mean().reset_index()
        
        # Calculer l'heure de d√©but moyenne par activit√© et par jour
        self.avg_start_time = grouped['start_time_minutes'].mean().reset_index()
        
        # Calculer la fr√©quence des activit√©s par jour
        self.activity_frequency = grouped.size().reset_index(name='frequency')
    
    def reset(self):
        """R√©initialise l'environnement et retourne l'√©tat initial."""
        # Choisir un jour al√©atoire de la semaine (1-7)
        self.current_day = np.random.randint(1, 8)
        
        # Initialiser un agenda vide
        self.current_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Initialiser le temps disponible (24 heures = 24 cr√©neaux)
        self.available_time = self.n_time_slots
        
        # Initialiser la liste des activit√©s planifi√©es
        self.scheduled_activities = []
        
        # Cr√©er un vecteur one-hot pour le jour de la semaine
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1  # -1 car l'indexation commence √† 0
        
        # Retourner l'√©tat initial
        return {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
    
    def step(self, action):
        """
        Ex√©cute une action dans l'environnement et retourne le nouvel √©tat,
        la r√©compense, le statut de fin et des informations suppl√©mentaires.
        
        Action: (activit√©_id, cr√©neau_horaire)
        """
        activity_id, time_slot = action
        activity_name = self.activity_types[activity_id]
        
        # V√©rifier si le cr√©neau horaire est disponible
        if self.current_schedule[time_slot].sum() > 0:
            reward = -1.0  # P√©nalit√© pour conflit horaire
            done = False
            info = {'status': 'conflict', 'activity': activity_name, 'time_slot': time_slot}
        else:
            # Planifier l'activit√©
            self.current_schedule[time_slot, activity_id] = 1
            self.available_time -= 1
            self.scheduled_activities.append((activity_name, time_slot))
            
            # Calculer la r√©compense bas√©e sur les pr√©f√©rences utilisateur
            reward = self._compute_reward(activity_name, time_slot)
            
            # V√©rifier si toutes les activit√©s ont √©t√© planifi√©es ou si le temps est √©coul√©
            done = len(self.scheduled_activities) >= self.max_activities or self.available_time <= 0
            
            info = {'status': 'scheduled', 'activity': activity_name, 'time_slot': time_slot}
        
        # Construire le nouvel √©tat
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1
        
        state = {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
        
        return state, reward, done, info
    
    def _compute_reward(self, activity_name, time_slot):
        """
        Calcule la r√©compense pour une activit√© planifi√©e √† un cr√©neau horaire sp√©cifique,
        bas√© sur les pr√©f√©rences historiques de l'utilisateur.
        """
        # Convertir le cr√©neau horaire en minutes (1 cr√©neau = 1 heure = 60 minutes)
        scheduled_time = time_slot * 60
        
        # Trouver les statistiques pour cette activit√© et ce jour de la semaine
        act_stats = self.avg_start_time[
            (self.avg_start_time['ACTIVITY_NAME'] == activity_name) & 
            (self.avg_start_time['TUDIARYDAY'] == self.current_day)
        ]
        
        if not act_stats.empty:
            # Calculer la diff√©rence entre l'heure planifi√©e et l'heure pr√©f√©r√©e (en minutes)
            preferred_time = act_stats['start_time_minutes'].values[0]
            time_diff = abs(scheduled_time - preferred_time)
            
            # La r√©compense diminue avec l'√©cart par rapport √† l'heure pr√©f√©r√©e
            # Normaliser pour que la r√©compense soit entre 0 et 1
            time_reward = max(0, 1 - (time_diff / (12 * 60)))  # max 12h de diff√©rence
        else:
            # Si nous n'avons pas d'information sur cette activit√© pour ce jour
            time_reward = 0.5  # R√©compense neutre
        
        # Bonus pour une planification coh√©rente (activit√©s similaires regroup√©es)
        coherence_reward = 0
        if len(self.scheduled_activities) > 0:
            for prev_activity, prev_slot in self.scheduled_activities:
                # R√©compense pour les activit√©s similaires regroup√©es
                if prev_activity == activity_name and abs(prev_slot - time_slot) <= 1:
                    coherence_reward += 0.2
                # P√©nalit√© pour les activit√©s qui devraient √™tre espac√©es
                elif prev_activity == activity_name and abs(prev_slot - time_slot) < 3:
                    coherence_reward -= 0.1
        
        # La r√©compense finale est une combinaison de r√©compenses bas√©es sur le temps et la coh√©rence
        reward = time_reward + coherence_reward
        
        return reward
    
    def render(self, mode='human'):
        """Affiche l'√©tat actuel de l'environnement pour le d√©bogage."""
        if mode != 'human':
            return
        
        print("\n===== √âTAT ACTUEL DE L'AGENDA =====")
        print(f"Jour de la semaine: {self.current_day}")
        print(f"Temps restant: {self.available_time} cr√©neaux")
        print("\nActivit√©s planifi√©es:")
        
        for i, (activity, time_slot) in enumerate(self.scheduled_activities):
            print(f"{i+1}. {activity} √† {time_slot}:00")
        
        print("\nGrille horaire:")
        for slot in range(self.n_time_slots):
            activities = [self.activity_types[i] for i in range(len(self.activity_types)) 
                         if self.current_schedule[slot, i] > 0]
            print(f"{slot}:00 - {activities if activities else 'Libre'}")
        
        print("====================================\n")
    
    def close(self):
        """Lib√®re les ressources."""
        pass

    def get_optimal_schedule(self):
        """
        G√©n√®re un emploi du temps optimal bas√© sur les pr√©f√©rences utilisateur.
        Utilis√© pour comparer les performances du mod√®le DQN.
        """
        # Cr√©er un agenda vide
        optimal_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Filtrer les activit√©s pour le jour actuel
        day_activities = self.avg_start_time[self.avg_start_time['TUDIARYDAY'] == self.current_day]
        
        # Trier par fr√©quence (priorit√© aux activit√©s les plus fr√©quentes)
        day_activities = day_activities.merge(self.activity_frequency, 
                                          on=['ACTIVITY_NAME', 'TUDIARYDAY'])
        day_activities = day_activities.sort_values('frequency', ascending=False)
        
        # Planifier les activit√©s √† leur heure pr√©f√©r√©e
        for _, row in day_activities.iterrows():
            activity_name = row['ACTIVITY_NAME']
            preferred_time_minutes = row['start_time_minutes']
            
            # Convertir en cr√©neau horaire (arrondi √† l'heure la plus proche)
            preferred_slot = int(round(preferred_time_minutes / 60)) % self.n_time_slots
            
            # V√©rifier si le cr√©neau est disponible
            if optimal_schedule[preferred_slot].sum() == 0:
                # Trouver l'index de l'activit√©
                activity_idx = np.where(self.activity_types == activity_name)[0][0]
                
                # Planifier l'activit√©
                optimal_schedule[preferred_slot, activity_idx] = 1
            else:
                # Chercher le cr√©neau disponible le plus proche
                for offset in range(1, self.n_time_slots // 2):
                    # Essayer le cr√©neau avant
                    before_slot = (preferred_slot - offset) % self.n_time_slots
                    if optimal_schedule[before_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[before_slot, activity_idx] = 1
                        break
                    
                    # Essayer le cr√©neau apr√®s
                    after_slot = (preferred_slot + offset) % self.n_time_slots
                    if optimal_schedule[after_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[after_slot, activity_idx] = 1
                        break
        
        return optimal_schedule
le voila mon code pour le fichiers 2_data_preprocessing.ipynb:
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
import os
import pickle
cols_to_load = [
    'TUACTDUR24',    # Dur√©e de l'activit√© (en minutes)
    'ACTIVITY_NAME', # Nom de l'activit√©
    'TUSTARTTIM',    # Heure de d√©but (format HH:MM:SS)
    'TUDIARYDAY'     # Jour de la semaine (1=dimanche, 7=samedi)
]
df = pd.read_csv("../Data/raw/atus_full_selected.csv", usecols=cols_to_load)
df.info(), df.describe(), df.head()
#2. Nettoyage des donn√©es
df.dropna(inplace=True)
df.reset_index(drop=True, inplace=True)
print(df.isnull().sum())
# Visualisation : distribution des dur√©es d'activit√©
plt.figure(figsize=(10, 5))
sns.histplot(df['TUACTDUR24'], bins=50, kde=True)
plt.title("Distribution des dur√©es d'activit√©s (en minutes)")
plt.xlabel("Dur√©e")
plt.ylabel("Fr√©quence")
plt.grid(True)
plt.tight_layout()
plt.show()
# 3. Conversion HH:MM:SS ‚Üí minutes
def time_to_minutes(t):
    try:
        hh, mm, ss = map(int, t.split(':'))
        return hh * 60 + mm
    except:
        return 0  # Valeur par d√©faut
df['START_MINUTES'] = df['TUSTARTTIM'].apply(time_to_minutes)
 #Visualisation : heures de d√©but d'activit√©
plt.figure(figsize=(10, 5))
sns.histplot(df['START_MINUTES'], bins=48, kde=True)
plt.title("Heures de d√©but des activit√©s (en minutes depuis minuit)")
plt.xlabel("Minutes depuis minuit")
plt.ylabel("Fr√©quence")
plt.grid(True)
plt.tight_layout()
plt.show()
# 4. Encodage des activit√©s
activity_encoder = LabelEncoder()
df['ACTIVITY_CODE'] = activity_encoder.fit_transform(df['ACTIVITY_NAME'])

top_activities = df['ACTIVITY_NAME'].value_counts().nlargest(10)
plt.figure(figsize=(12, 6))
sns.barplot(x=top_activities.values, y=top_activities.index, palette="viridis")
plt.title("Top 10 des activit√©s les plus fr√©quentes")
plt.xlabel("Nombre d‚Äôoccurrences")
plt.ylabel("Activit√©")
plt.tight_layout()
plt.show()
# 5. Transformation du jour de la semaine
df['DAY_OF_WEEK'] = df['TUDIARYDAY'] - 1  # 0=dimanche, 6=samedi
df['IS_WEEKEND'] = (df['DAY_OF_WEEK'] >= 5).astype(int)
# Visualisation : r√©partition des jours
plt.figure(figsize=(8, 4))
sns.countplot(x='DAY_OF_WEEK', data=df, palette="pastel")
plt.title("R√©partition des activit√©s par jour de la semaine (0=dim, 6=sam)")
plt.xlabel("Jour de la semaine")
plt.ylabel("Nombre d‚Äôactivit√©s")
plt.tight_layout()
plt.show()
# Visualisation : proportion weekend/semaine
plt.figure(figsize=(6, 4))
df['IS_WEEKEND'].value_counts().plot.pie(autopct='%1.1f%%', labels=['Semaine', 'Weekend'], colors=['#66c2a5', '#fc8d62'])
plt.title("Proportion des activit√©s semaine vs weekend")
plt.ylabel("")
plt.tight_layout()
plt.show()
# 6. S√©lection finale des colonnes utiles
final_columns = [
    'ACTIVITY_CODE',
    'TUACTDUR24',
    'START_MINUTES',
    'DAY_OF_WEEK',
    'IS_WEEKEND'
]
final_df = df[final_columns]
# 7. Sauvegarde des donn√©es transform√©es
os.makedirs("../Data/processed", exist_ok=True)
final_df.to_csv("../Data/processed/cleaned_data.csv", index=False)
with open("../Data/processed/activity_encoder.pkl", "wb") as f:
    pickle.dump(activity_encoder, f)
le voila mon code pour le fichiers 3_dqn_training.ipynb:
import numpy as np
import pandas as pd
import tensorflow as tf
from collections import deque
import random
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import sys
# Ajouter le chemin du dossier parent (si besoin d'importer ScheduleEnv)
parent_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))
sys.path.append(parent_dir)
from environment.schedule_env import ScheduleEnv
# 1. Chargement des donn√©es
df = pd.read_csv("../Data/processed/cleaned_data.csv")

# 2. Initialiser l'environnement
env = ScheduleEnv(data_path="../Data/processed/cleaned_data.csv")
# Calculer la taille de l'√©tat
n_activities = len(env.activity_types)
state_size = env.n_time_slots * n_activities + env.days_of_week + 1  # schedule + day_of_week + time_remaining
action_size = env.action_space.nvec[0] * env.action_space.nvec[1]  # Nombre total d'actions possibles

print(f"\n‚úÖ Environnement cr√©√© avec {action_size} actions possibles")
# 3. Param√®tres du DQN
memory = deque(maxlen=2000)
batch_size = 32
gamma = 0.95
epsilon = 1.0
epsilon_min = 0.01
epsilon_decay = 0.995
# 4. Cr√©ation du mod√®le DQN
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, input_dim=state_size, activation='relu'),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(action_size, activation='linear')
])
model.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer=tf.keras.optimizers.Adam(0.001))

# Cr√©ation du mod√®le cible
target_model = tf.keras.models.clone_model(model)
target_model.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer=tf.keras.optimizers.Adam(0.001))
target_model.set_weights(model.get_weights())
# 5. Fonction pour mettre √† jour les graphiques
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plt.ion()
def update_plots(rewards, mean_rewards, epsilons, losses):
    ax1.clear()
    ax2.clear()
    
    ax1.plot(rewards, label='R√©compense par √©pisode', alpha=0.4)
    ax1.plot(mean_rewards, label='Moyenne glissante (20)', color='red')
    ax1.set_title('√âvolution des r√©compenses')
    ax1.set_xlabel('√âpisode')
    ax1.set_ylabel('R√©compense')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(epsilons, label='Epsilon', color='green')
    if losses:
        ax2.plot(losses, label='Perte (Loss)', color='orange')
    ax2.set_title("√âvolution de l'epsilon et des pertes")
    ax2.set_xlabel("√âpisode")
    ax2.legend()
    ax2.grid(True)

    plt.tight_layout()
    plt.draw()
    plt.pause(0.001)

# 6. Entra√Ænement du DQN
def train_dqn(episodes=300):
    global epsilon
    rewards_history = []
    epsilons = []
    mean_rewards = []
    loss_history = []

    progress_bar = tqdm(range(episodes), desc="üîÅ Entra√Ænement DQN", unit="episode")

    for episode in progress_bar:
        state = env.reset()
        state_flat = np.concatenate([state['schedule'].flatten(), state['day_of_week'], state['time_remaining']])
        state = np.reshape(state_flat, [1, state_size])
        total_reward = 0
        done = False
        episode_loss = []

        while not done:
            if np.random.rand() <= epsilon:
                action = env.action_space.sample()
                action_idx = action[0] * env.n_time_slots + action[1]
            else:
                q_values = model.predict(state, verbose=0)[0]
                action_idx = np.argmax(q_values)
                action = np.array([action_idx // env.n_time_slots, action_idx % env.n_time_slots])

            next_state, reward, done, _ = env.step(action)
            next_state_flat = np.concatenate([
                next_state['schedule'].flatten(), 
                next_state['day_of_week'], 
                next_state['time_remaining']
            ])
            next_state = np.reshape(next_state_flat, [1, state_size])

            memory.append((state, action_idx, reward, next_state, done))
            state = next_state
            total_reward += reward

            if len(memory) >= batch_size:
                minibatch = random.sample(memory, batch_size)
                states = np.array([x[0][0] for x in minibatch])
                actions = np.array([x[1] for x in minibatch])
                rewards_batch = np.array([x[2] for x in minibatch])
                next_states = np.array([x[3][0] for x in minibatch])
                dones = np.array([x[4] for x in minibatch])

                targets = model.predict(states, verbose=0)
                next_q_values = target_model.predict(next_states, verbose=0)

                for i in range(batch_size):
                    if dones[i]:
                        targets[i][actions[i]] = rewards_batch[i]
                    else:
                        targets[i][actions[i]] = rewards_batch[i] + gamma * np.max(next_q_values[i])

                history = model.fit(states, targets, epochs=1, verbose=0)
                episode_loss.append(history.history['loss'][0])

        if episode % 10 == 0:
            target_model.set_weights(model.get_weights())

        epsilon = max(epsilon_min, epsilon * epsilon_decay)
        rewards_history.append(total_reward)
        epsilons.append(epsilon)
        loss_history.append(np.mean(episode_loss) if episode_loss else 0)

        window_size = 20
        if episode >= window_size:
            mean_rewards.append(np.mean(rewards_history[-window_size:]))
        else:
            mean_rewards.append(np.mean(rewards_history))

        progress_bar.set_postfix({
            'Reward': f"{total_reward:.1f}",
            'Epsilon': f"{epsilon:.2f}",
            'AvgReward': f"{mean_rewards[-1]:.1f}",
            'Loss': f"{loss_history[-1]:.4f}" if episode_loss else "N/A"
        })

        if episode % 10 == 0:
            update_plots(rewards_history, mean_rewards, epsilons, loss_history)

    plt.ioff()
    plt.show()
    return rewards_history, mean_rewards, loss_history

# 7. Lancer l'entra√Ænement
print("\nüöÄ D√©but de l'entra√Ænement...")
rewards, avg_rewards, losses = train_dqn(episodes=300)
# 8. Sauvegarde du mod√®le
os.makedirs("../models", exist_ok=True)
model.save("../models/dqn_schedule_model.h5")
plt.figure(figsize=(10, 4))
plt.plot(rewards, label="R√©compense par √©pisode", alpha=0.4)
plt.plot(avg_rewards, label="R√©compense moyenne (20 √©pisodes)", color='red')
plt.title("√âvolution des R√©compenses")
plt.xlabel("√âpisode")
plt.ylabel("R√©compense")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 4))
plt.plot(losses, label="Perte moyenne", color='orange')
plt.title("√âvolution de la Perte pendant l'Entra√Ænement")
plt.xlabel("√âpisode")
plt.ylabel("Loss")
plt.grid(True)
plt.show()
le voila mon code pour le fichiers app.py:
"""
Application Streamlit pour l'Assistant Personnel de Gestion du Temps
Utilise un mod√®le DQN pour optimiser les plannings personnels des utilisateurs
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow.keras.models import load_model
import sys
import os
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path

# V√©rifier la version de TensorFlow
print(f"TensorFlow version: {tf.__version__}")

# Ajouter le r√©pertoire parent au chemin pour importer les modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from environment.schedule_env import ScheduleEnv

# Configuration de la page
st.set_page_config(
    page_title="Assistant Personnel de Gestion du Temps",
    page_icon="üìÖ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Chemins de fichiers
MODEL_PATH = '../models/dqn_schedule_model.h5'
DATA_PATH = '../Data/processed/cleaned_data.csv'

# V√©rification des fichiers
if not os.path.exists(MODEL_PATH):
    st.error(f"Le fichier mod√®le n'existe pas : {MODEL_PATH}")
if not os.path.exists(DATA_PATH):
    st.warning(f"Le fichier de donn√©es n'existe pas : {DATA_PATH}. Utilisation de donn√©es synth√©tiques.")

DEFAULT_ACTIVITIES = [
    'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
    'Sommeil', 'T√¢ches m√©nag√®res', 'Courses', 'Socialisation', 'Apprentissage'
]
ACTIVITY_COLORS = {
    'Travail': '#FF6B6B',
    'Repas': '#4ECDC4',
    'Transport': '#FFD166',
    'Loisirs': '#6B5B95',
    'Sport': '#88D8B0',
    'Sommeil': '#5D535E',
    'T√¢ches m√©nag√®res': '#F7B801',
    'Courses': '#F18701',
    'Socialisation': '#7BDFF2',
    'Apprentissage': '#B2DBBF'
}
DEFAULT_COLOR = '#CCCCCC'

# Fonction pour charger le mod√®le
@st.cache_resource
def load_dqn_model():
    """Charge le mod√®le DQN pr√©-entra√Æn√©"""
    try:
        model = load_model(MODEL_PATH)
        return model
    except Exception as e:
        st.error(f"Erreur lors du chargement du mod√®le: {str(e)}")
        return None

# Fonction pour charger les donn√©es
@st.cache_data
def load_data():
    """Charge les donn√©es pr√©trait√©es"""
    try:
        data = pd.read_csv(DATA_PATH)
        return data
    except Exception as e:
        st.warning(f"Erreur lors du chargement des donn√©es: {str(e)}")
        st.info("Utilisation de donn√©es par d√©faut")
        return None

# Cr√©er un environnement Gym pour l'optimisation de planning
def create_environment(data=None, user_activities=None):
    """Cr√©e l'environnement de simulation pour l'optimisation de planning"""
    if user_activities is None:
        user_activities = DEFAULT_ACTIVITIES
    
    env = ScheduleEnv(data_path=DATA_PATH if data is not None else None)
    
    if user_activities:
        env.activity_types = np.array(user_activities)
    
    return env

# Fonction pour g√©n√©rer un planning optimis√© avec DQN
def generate_optimized_schedule(env, model, user_constraints=None, day_of_week=None):
    """
    G√©n√®re un planning optimis√© en utilisant le mod√®le DQN
    
    Args:
        env: Environnement de simulation
        model: Mod√®le DQN pr√©-entra√Æn√©
        user_constraints: Dictionnaire de contraintes utilisateur
        day_of_week: Jour de la semaine sp√©cifique (1-7, lundi-dimanche)
        
    Returns:
        schedule: Planning g√©n√©r√© (matrice)
        activities: Liste des activit√©s planifi√©es (avec heures et dur√©es)
        rewards: R√©compenses obtenues
    """
    state = env.reset()
    
    if day_of_week is not None:
        env.current_day = day_of_week
        day_of_week_vector = np.zeros(env.days_of_week)
        day_of_week_vector[env.current_day - 1] = 1
        state['day_of_week'] = day_of_week_vector
    
    if user_constraints:
        for activity, time_slots in user_constraints.items():
            if activity in env.activity_types:
                activity_idx = np.where(env.activity_types == activity)[0][0]
                for slot in time_slots:
                    if 0 <= slot < env.n_time_slots:
                        env.current_schedule[slot, activity_idx] = 1
                        env.available_time -= 1
    
    done = False
    total_reward = 0
    activities_planned = []
    
    while not done and env.available_time > 0:
        schedule_flat = state['schedule'].flatten()
        day_of_week = state['day_of_week']
        time_remaining = state['time_remaining']
        state_tensor = np.concatenate([schedule_flat, day_of_week, time_remaining])
        state_tensor = np.expand_dims(state_tensor, 0)
        
        act_values = model.predict(state_tensor, verbose=0)[0]
        
        n_activities = len(env.activity_types)
        action_idx = np.argmax(act_values)
        activity_id = action_idx // env.n_time_slots
        time_slot = action_idx % env.n_time_slots
        action = np.array([activity_id, time_slot])
        
        while env.current_schedule[action[1]].sum() > 0:
            act_values[action_idx] = -np.inf
            action_idx = np.argmax(act_values)
            activity_id = action_idx // env.n_time_slots
            time_slot = action_idx % env.n_time_slots
            action = np.array([activity_id, time_slot])
            
            if np.all(act_values == -np.inf):
                done = True
                break
        
        if not done:
            next_state, reward, done, info = env.step(action)
            
            state = next_state
            total_reward += reward
            
            activity_name = env.activity_types[action[0]]
            duration_stats = env.avg_duration[
                (env.avg_duration['ACTIVITY_NAME'] == activity_name) & 
                (env.avg_duration['TUDIARYDAY'] == env.current_day)
            ]
            duration = float(duration_stats['TUACTDUR24'].values[0]) if not duration_stats.empty else 60.0
            duration = min(duration, 240.0)  # Cap duration at 4 hours
            
            time_slot = action[1]
            activities_planned.append((activity_name, time_slot, reward, duration))
    
    return env.current_schedule, activities_planned, total_reward

# Fonction pour visualiser le planning avec Plotly
def visualize_schedule_plotly(schedule, activities, activity_types, reference_date="2025-05-12"):
    """Cr√©e une visualisation interactive du planning avec Plotly"""
    from datetime import datetime, timedelta
    
    schedule_data = []
    
    for activity_name, time_slot, reward, duration in activities:
        # Calculate start time as a datetime
        start_hour = time_slot
        start_time = datetime.strptime(f"{reference_date} {start_hour:02d}:00", "%Y-%m-%d %H:%M")
        
        # Calculate end time
        end_time_minutes = time_slot * 60 + duration
        days_offset = int(end_time_minutes // 1440)  # Number of days to add if exceeding 24 hours
        end_time_minutes = end_time_minutes % 1440  # Minutes within the day
        end_hour = int(end_time_minutes // 60)
        end_minute = int(end_time_minutes % 60)
        
        # Parse end time, adjusting date if necessary
        end_date = datetime.strptime(reference_date, "%Y-%m-%d") + timedelta(days=days_offset)
        end_time = datetime.strptime(
            f"{end_date.strftime('%Y-%m-%d')} {end_hour:02d}:{end_minute:02d}", 
            "%Y-%m-%d %H:%M"
        )
        
        schedule_data.append({
            'Heure_D√©but': start_time,
            'Heure_Fin': end_time,
            'Activit√©': activity_name,
            'Valeur': 1,
            'Couleur': ACTIVITY_COLORS.get(activity_name, DEFAULT_COLOR)
        })
    
    if not schedule_data:
        st.warning("Aucune activit√© n'a pu √™tre planifi√©e.")
        return go.Figure()
    
    schedule_df = pd.DataFrame(schedule_data)
    
    fig = px.timeline(
        schedule_df, 
        x_start="Heure_D√©but", 
        x_end="Heure_Fin", 
        y="Activit√©", 
        color="Activit√©",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Journalier Optimis√©"
    )
    
    fig.update_layout(
        xaxis_title="Heure de la journ√©e",
        yaxis_title="Activit√©",
        height=600,
        showlegend=True,
        xaxis=dict(
            tickformat="%H:%M",  # Display only time (HH:MM)
            tickangle=45
        )
    )
    
    return fig

# Fonction pour cr√©er un calendrier hebdomadaire
def create_weekly_calendar(daily_schedules, activity_types, all_activities_planned):
    """Cr√©e un calendrier hebdomadaire √† partir des plannings quotidiens"""
    from datetime import datetime, timedelta
    
    days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']
    day_to_date = {
        'Lundi': '2025-05-12',
        'Mardi': '2025-05-13',
        'Mercredi': '2025-05-14',
        'Jeudi': '2025-05-15',
        'Vendredi': '2025-05-16',
        'Samedi': '2025-05-17',
        'Dimanche': '2025-05-18'
    }
    calendar_data = []
    
    for act, time_slot, reward, duration, day in all_activities_planned:
        day_name = days[day - 1]
        reference_date = day_to_date[day_name]
        
        start_time = datetime.strptime(f"{reference_date} {time_slot:02d}:00", "%Y-%m-%d %H:%M")
        
        end_time_minutes = time_slot * 60 + duration
        days_offset = int(end_time_minutes // 1440)
        end_time_minutes = end_time_minutes % 1440
        end_hour = int(end_time_minutes // 60)
        end_minute = int(end_time_minutes % 60)
        
        end_date = datetime.strptime(reference_date, "%Y-%m-%d") + timedelta(days=days_offset)
        end_time = datetime.strptime(
            f"{end_date.strftime('%Y-%m-%d')} {end_hour:02d}:{end_minute:02d}", 
            "%Y-%m-%d %H:%M"
        )
        
        calendar_data.append({
            'Jour': day_name,
            'Heure_D√©but': start_time,
            'Heure_Fin': end_time,
            'Activit√©': act,
            'Couleur': ACTIVITY_COLORS.get(act, DEFAULT_COLOR)
        })
    
    if not calendar_data:
        st.warning("Aucune activit√© n'a pu √™tre planifi√©e pour la semaine.")
        return go.Figure()
    
    calendar_df = pd.DataFrame(calendar_data)
    
    fig = px.timeline(
        calendar_df, 
        x_start="Heure_D√©but", 
        x_end="Heure_Fin", 
        y="Jour", 
        color="Activit√©",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Hebdomadaire Optimis√©"
    )
    
    fig.update_layout(
        xaxis_title="Heure de la journ√©e",
        yaxis_title="Jour de la semaine",
        height=600,
        showlegend=True,
        xaxis=dict(
            tickformat="%H:%M",
            tickangle=45
        )
    )
    
    return fig

# Fonction pour calculer des statistiques sur le planning
def calculate_schedule_stats(activities):
    """Calcule des statistiques sur le planning g√©n√©r√©"""
    if not activities:
        return {}
    
    activity_counts = {}
    for activity, time_slot, reward, duration in activities:
        if activity in activity_counts:
            activity_counts[activity] += 1
        else:
            activity_counts[activity] = 1
    
    rewards_by_hour = {}
    for activity, time_slot, reward, duration in activities:
        if time_slot in rewards_by_hour:
            rewards_by_hour[time_slot] += reward
        else:
            rewards_by_hour[time_slot] = reward
    
    most_productive_hour = max(rewards_by_hour, key=rewards_by_hour.get) if rewards_by_hour else None
    
    return {
        'activity_counts': activity_counts,
        'rewards_by_hour': rewards_by_hour,
        'most_productive_hour': most_productive_hour
    }

# Interface utilisateur avec Streamlit
def main():
    st.title("üìÖ Assistant Personnel de Gestion du Temps")
    st.subheader("Optimisez votre planning quotidien avec l'intelligence artificielle")
    
    model = load_dqn_model()
    data = load_data()
    
    if model is None:
        st.error("Le mod√®le DQN n'a pas pu √™tre charg√©. Veuillez v√©rifier le fichier mod√®le.")
        return
    
    st.sidebar.title("Param√®tres")
    
    planning_type = st.sidebar.radio(
        "Type de planning",
        ["üìÜ Planning quotidien", "üóìÔ∏è Planning hebdomadaire"]
    )
    
    day_options = {
        "Lundi": 1, "Mardi": 2, "Mercredi": 3, "Jeudi": 4, 
        "Vendredi": 5, "Samedi": 6, "Dimanche": 7
    }
    
    if planning_type == "üìÜ Planning quotidien":
        selected_day_name = st.sidebar.selectbox(
            "Jour de la semaine",
            list(day_options.keys())
        )
        selected_day = day_options[selected_day_name]
    else:
        selected_day = None
    
    st.sidebar.subheader("Activit√©s personnalis√©es")
    
    use_default_activities = st.sidebar.checkbox("Utiliser les activit√©s par d√©faut", value=True)
    
    if use_default_activities:
        activities = DEFAULT_ACTIVITIES
    else:
        custom_activities_input = st.sidebar.text_area(
            "Entrez vos activit√©s (une par ligne)",
            value="\n".join(DEFAULT_ACTIVITIES)
        )
        activities = [act.strip() for act in custom_activities_input.split("\n") if act.strip()]
    
    st.sidebar.subheader("Liste des activit√©s")
    for i, activity in enumerate(activities):
        color = ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
        st.sidebar.markdown(
            f"<div style='background-color:{color}; padding:5px; border-radius:5px; margin:2px 0;'>"
            f"{i+1}. {activity}</div>",
            unsafe_allow_html=True
        )
    
    st.sidebar.subheader("Contraintes (optionnel)")
    add_constraints = st.sidebar.checkbox("Ajouter des contraintes horaires")
    
    user_constraints = {}
    if add_constraints:
        constraint_activity = st.sidebar.selectbox(
            "Activit√©",
            activities
        )
        
        constraint_time = st.sidebar.multiselect(
            "Horaires (obligatoires)",
            [f"{h:02d}:00" for h in range(24)]
        )
        
        if st.sidebar.button("Ajouter cette contrainte"):
            time_slots = [int(t.split(":")[0]) for t in constraint_time]
            if constraint_activity in user_constraints:
                user_constraints[constraint_activity].extend(time_slots)
            else:
                user_constraints[constraint_activity] = time_slots
    
    if user_constraints:
        st.sidebar.subheader("Contraintes ajout√©es")
        for activity, slots in user_constraints.items():
            st.sidebar.write(f"{activity}: {', '.join([f'{s:02d}:00' for s in slots])}")
    
    if planning_type == "üìÜ Planning quotidien":
        generate_button = st.sidebar.button("G√©n√©rer planning quotidien")
    else:
        generate_button = st.sidebar.button("G√©n√©rer planning hebdomadaire")
    
    if generate_button:
        with st.spinner("G√©n√©ration du planning en cours..."):
            env = create_environment(data, activities)
            
            if planning_type == "üìÜ Planning quotidien":
                schedule, activities_planned, total_reward = generate_optimized_schedule(
                    env, model, user_constraints, selected_day
                )
                
                st.subheader(f"Planning optimis√© pour {selected_day_name}")
                
                # Map selected day to a date (week of 2025-05-12)
                day_to_date = {
                    "Lundi": "2025-05-12",
                    "Mardi": "2025-05-13",
                    "Mercredi": "2025-05-14",
                    "Jeudi": "2025-05-15",
                    "Vendredi": "2025-05-16",
                    "Samedi": "2025-05-17",
                    "Dimanche": "2025-05-18"
                }
                reference_date = day_to_date[selected_day_name]
                
                fig = visualize_schedule_plotly(schedule, activities_planned, env.activity_types, reference_date)
                st.plotly_chart(fig, use_container_width=True)
                
                if activities_planned:
                    st.subheader("D√©tail des activit√©s")
                    
                    activities_df = pd.DataFrame([
                        (act, f"{slot:02d}:00", f"{reward:.2f}", f"{duration:.0f} min") 
                        for act, slot, reward, duration in activities_planned
                    ], columns=["Activit√©", "Heure", "Score", "Dur√©e"])
                    
                    st.dataframe(activities_df.sort_values(by="Heure"), use_container_width=True)
                    
                    stats = calculate_schedule_stats(activities_planned)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("Distribution des activit√©s")
                        if stats['activity_counts']:
                            fig = px.pie(
                                values=list(stats['activity_counts'].values()),
                                names=list(stats['activity_counts'].keys()),
                                title="Distribution des activit√©s",
                                color=list(stats['activity_counts'].keys()),
                                color_discrete_map=ACTIVITY_COLORS
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with col2:
                        st.subheader("Productivit√© par heure")
                        if stats['rewards_by_hour']:
                            hours = [f"{h:02d}:00" for h in stats['rewards_by_hour'].keys()]
                            rewards = list(stats['rewards_by_hour'].values())
                            
                            fig = px.bar(
                                x=hours,
                                y=rewards,
                                title="Score de productivit√© par heure",
                                labels={'x': 'Heure', 'y': 'Score de productivit√©'}
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    if stats['most_productive_hour'] is not None:
                        st.info(f"‚ú® Votre heure la plus productive est {stats['most_productive_hour']:02d}:00")
                
                st.subheader("√âvaluation du planning")
                st.write(f"Score total du planning: {total_reward:.2f}")
                
                quality = min(max(total_reward / 10, 0), 1)
                
                gauge = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=quality * 100,
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': "Qualit√© du planning"},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 33], 'color': "red"},
                            {'range': [33, 66], 'color': "yellow"},
                            {'range': [66, 100], 'color': "green"}
                        ]
                    }
                ))
                
                st.plotly_chart(gauge, use_container_width=True)
                
                st.subheader("Recommandations")
                
                if quality < 0.4:
                    st.warning("Votre planning pourrait √™tre am√©lior√©. Essayez d'ajouter plus de contraintes ou de modifier vos activit√©s.")
                elif quality < 0.7:
                    st.info("Votre planning est bon, mais il pourrait encore √™tre optimis√©.")
                else:
                    st.success("Excellent planning ! Votre journ√©e est optimis√©e pour une productivit√© maximale.")
            
            else:
                st.subheader("Planning hebdomadaire optimis√©")
                
                daily_schedules = []
                all_activities_planned = []
                total_weekly_reward = 0
                
                for day in range(1, 8):
                    day_schedule, day_activities, day_reward = generate_optimized_schedule(
                        env, model, user_constraints, day
                    )
                    daily_schedules.append(day_schedule)
                    all_activities_planned.extend([(act, slot, reward, duration, day) for act, slot, reward, duration in day_activities])
                    total_weekly_reward += day_reward
                
                fig = create_weekly_calendar(daily_schedules, env.activity_types, all_activities_planned)
                st.plotly_chart(fig, use_container_width=True)
                
                st.subheader("Statistiques hebdomadaires")
                
                activities_by_day = {}
                for day_idx in range(7):
                    day_name = list(day_options.keys())[day_idx]
                    day_activities = [act for act, _, _, _, day in all_activities_planned if day == day_idx + 1]
                    activities_by_day[day_name] = len(day_activities)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Activit√©s par jour")
                    fig = px.bar(
                        x=list(activities_by_day.keys()),
                        y=list(activities_by_day.values()),
                        title="Nombre d'activit√©s par jour",
                        labels={'x': 'Jour', 'y': 'Nombre d\'activit√©s'}
                    )
                    st.plotly_chart(fig, use_container_width=True)
                
                with col2:
                    st.subheader("Score hebdomadaire")
                    st.write(f"Score total de la semaine: {total_weekly_reward:.2f}")
                    
                    quality = min(max(total_weekly_reward / 70, 0), 1)
                    
                    gauge = go.Figure(go.Indicator(
                        mode="gauge+number",
                        value=quality * 100,
                        domain={'x': [0, 1], 'y': [0, 1]},
                        title={'text': "Qualit√© du planning hebdomadaire"},
                        gauge={
                            'axis': {'range': [0, 100]},
                            'bar': {'color': "darkblue"},
                            'steps': [
                                {'range': [0, 33], 'color': "red"},
                                {'range': [33, 66], 'color': "yellow"},
                                {'range': [66, 100], 'color': "green"}
                            ]
                        }
                    ))
                    
                    st.plotly_chart(gauge, use_container_width=True)
                
                activity_counts = {}
                for act, _, _, _, _ in all_activities_planned:
                    if act in activity_counts:
                        activity_counts[act] += 1
                    else:
                        activity_counts[act] = 1
                
                st.subheader("R√©partition des activit√©s sur la semaine")
                fig = px.pie(
                    values=list(activity_counts.values()),
                    names=list(activity_counts.keys()),
                    title="Distribution des activit√©s sur la semaine",
                    color=list(activity_counts.keys()),
                    color_discrete_map=ACTIVITY_COLORS
                )
                st.plotly_chart(fig, use_container_width=True)
                
                st.subheader("Exporter le planning")
                
                export_data = []
                days = list(day_options.keys())
                
                for day_idx, day_name in enumerate(days):
                    day_activities = [(act, slot, duration) for act, slot, _, duration, day in all_activities_planned if day == day_idx + 1]
                    for activity, time_slot, duration in day_activities:
                        export_data.append({
                            'Jour': day_name,
                            'Heure_D√©but': f"{time_slot:02d}:00",
                            'Dur√©e': f"{duration:.0f} min",
                            'Activit√©': activity
                        })
                
                export_df = pd.DataFrame(export_data)
                
                csv = export_df.to_csv(index=False)
                st.download_button(
                    label="T√©l√©charger le planning (CSV)",
                    data=csv,
                    file_name=f"planning_hebdomadaire_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv"
                )
    
    else:
        st.write("""
        Bienvenue dans votre Assistant Personnel de Gestion du Temps ! Cette application utilise l'intelligence artificielle
        pour vous aider √† optimiser votre emploi du temps quotidien ou hebdomadaire.
        
        ### Comment √ßa marche ?
        
        Notre application utilise un algorithme d'apprentissage par renforcement appel√© **Deep Q-Network (DQN)** pour analyser vos habitudes
        et pr√©f√©rences, puis g√©n√©rer un planning optimis√© qui maximise votre productivit√© et votre satisfaction.
        
        ###Fonctionnalit√©s
        
        - **Planning quotidien**: Obtenez un emploi du temps optimis√© pour une journ√©e sp√©cifique
        - **Planning hebdomadaire**: Visualisez un calendrier complet pour toute la semaine
        - **Activit√©s personnalis√©es**: D√©finissez vos propres types d'activit√©s
        - **Contraintes horaires**: Ajoutez des activit√©s obligatoires √† des heures pr√©cises
        - **Statistiques**: Analysez la qualit√© de votre planning et identifiez vos heures les plus productives
        
        ###Commencer
        
        Utilisez les options dans la barre lat√©rale pour personnaliser votre planning, puis cliquez sur "G√©n√©rer planning" pour voir les r√©sultats.
        """)
        
        st.image("../logo/4406306.png", 
                 caption="Optimisez votre temps avec l'IA")

if __name__ == "__main__":
    main()