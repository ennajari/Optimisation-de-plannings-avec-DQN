le voila mon projet :
titre :Assistant Personnel pour la Gestion du Temps
algorithme :Deep Q-Network
environnement/Donées : Données d'agenda personnel et historiques d'activités
methodes a utiliser : - Analyse des habitudes et préférences de l'utilisateur
- Application de DQN pour suggérer des plannings optimaux
- Évaluation basée sur l'amélioration de la productivité et la satisfaction de l'utilisateur
le voila mon structure :
📁 Optimisation-de-plannings-avec-DQN/
├── 📁 Data/                  # Données du projet
│   ├── 📁 Processed/        # Données prétraitées
│   │   ├── activity_encoder.pkl
│   │   └── cleaned_data.csv
│   └── 📁 raw/              # Données brutes
│       └── atus_full_selected.csv
├── 📁 environment/          # Environnement RL personnalisé
│   ├── 📄 schedule_env.py  # Implémentation de l'environnement Gym
├── 📁 models/              # Modèles entraînés
│   ├── dqn_final.h5
│   └── dqn_schedule_model.h5
├── 📁 notebooks/           # Notebooks Jupyter
│   ├── 2_data_preprocessing.ipynb  # Prétraitement des données
│   └── 3_dqn_training.ipynb       # Entraînement du DQN
└── 📁 ui/                  # Interface utilisateur
    └── 📄 app.py          # Application Streamlit

le voila mon code pour le fichiers schedule_env.py
"""
Environnement de planification pour l'Assistant Personnel de Gestion du Temps
Utilise un format compatible avec OpenAI Gym pour l'apprentissage par renforcement
"""
import numpy as np
import pandas as pd
import gym
from gym import spaces
from datetime import datetime, timedelta
import os

class ScheduleEnv(gym.Env):
    """
    Environnement de simulation pour la planification d'agenda personnel
    utilisant le format OpenAI Gym pour l'apprentissage par renforcement.
    """
    
    metadata = {'render.modes': ['human']}
    
    def __init__(self, data_path=None, user_id=None, n_time_slots=24, max_activities=10):
        super(ScheduleEnv, self).__init__()
        
        # Paramètres de l'environnement
        self.n_time_slots = n_time_slots  # 24 créneaux horaires (un par heure)
        self.max_activities = max_activities  # Nombre maximum d'activités à planifier
        self.days_of_week = 7  # Jour de la semaine (1-7)
        self.activity_types = None  # Sera défini lors du chargement des données
        
        # Charger et préprocesser les données
        self.load_user_data(data_path, user_id)
        
        # Définir l'espace d'actions : 
        # Pour chaque activité, on peut la planifier à n'importe quel créneau horaire
        # Actions: (activité_id, créneau_horaire)
        self.action_space = spaces.MultiDiscrete([
            len(self.activity_types), 
            self.n_time_slots
        ])
        
        # Définir l'espace d'observation
        # État: matrice [n_time_slots x n_activity_types] + vecteur jour de la semaine (one-hot)
        self.observation_space = spaces.Dict({
            'schedule': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.n_time_slots, len(self.activity_types)), 
                dtype=np.float32
            ),
            'day_of_week': spaces.Box(
                low=0, 
                high=1, 
                shape=(self.days_of_week,), 
                dtype=np.float32
            ),
            'time_remaining': spaces.Box(
                low=0, 
                high=self.n_time_slots, 
                shape=(1,), 
                dtype=np.float32
            )
        })
        
        # État actuel de l'environnement
        self.current_schedule = None
        self.current_day = None
        self.available_time = None
        self.scheduled_activities = None
        
        # Historique des activités pour l'apprentissage des préférences utilisateur
        self.activity_history = None
        
        # Reset pour initialiser l'environnement
        self.reset()
    
    def load_user_data(self, data_path, user_id=None):
        """
        Charge les données d'activités d'un utilisateur spécifique ou d'un ensemble d'utilisateurs.
        Ne conserve que les colonnes essentielles pour le projet.
        """
        if data_path is None:
            # Créer des données synthétiques pour les tests
            self._create_synthetic_data()
            return
        
        try:
            # Charger les données
            data = pd.read_csv(data_path)
            
            # Filtrer uniquement les colonnes essentielles
            essential_cols = ['TUCASEID', 'TUACTIVITY_N', 'TUACTDUR24', 
                             'TUSTARTTIM', 'ACTIVITY_NAME', 'TUDIARYDAY']
            data = data[essential_cols]
            
            # Filtrer pour un utilisateur spécifique si fourni
            if user_id:
                data = data[data['TUCASEID'] == user_id]
            
            # Extraire les types d'activités uniques
            self.activity_types = data['ACTIVITY_NAME'].unique()
            
            # Convertir les heures de début en format numérique (minutes depuis minuit)
            data['start_time_minutes'] = data['TUSTARTTIM'].apply(self._convert_time_to_minutes)
            
            # Calculer les heures de fin
            data['end_time_minutes'] = data['start_time_minutes'] + data['TUACTDUR24']
            
            # Stocker les données traitées
            self.user_data = data
            
            # Calculer les statistiques des activités pour l'apprentissage des préférences
            self._compute_activity_statistics()
            
        except Exception as e:
            print(f"Erreur lors du chargement des données: {str(e)}")
            # Créer des données synthétiques en cas d'erreur
            self._create_synthetic_data()
    
    def _convert_time_to_minutes(self, time_str):
        """Convertit une chaîne de temps HH:MM en minutes depuis minuit."""
        try:
            hours, minutes = map(int, time_str.split(':'))
            return hours * 60 + minutes
        except:
            # Imputer la moyenne des heures pour l'activité si disponible
            return 8 * 60  # Fallback: 8h du matin
    
    def _create_synthetic_data(self):
        """Crée des données synthétiques pour les tests."""
        # Définir des types d'activités de base
        self.activity_types = np.array([
            'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
            'Sommeil', 'Tâches ménagères', 'Courses', 'Socialisation', 'Apprentissage'
        ])
        
        # Créer un dataframe avec des données synthétiques
        n_samples = 100
        synthetic_data = {
            'TUCASEID': np.ones(n_samples),
            'TUACTIVITY_N': np.arange(n_samples),
            'ACTIVITY_NAME': np.random.choice(self.activity_types, n_samples),
            'TUACTDUR24': np.random.randint(15, 240, n_samples),  # 15min à 4h
            'start_time_minutes': np.random.randint(0, 24*60, n_samples),
            'TUDIARYDAY': np.random.randint(1, 8, n_samples)  # 1-7 (lundi-dimanche)
        }
        
        # Calculer les heures de fin
        synthetic_data['end_time_minutes'] = synthetic_data['start_time_minutes'] + synthetic_data['TUACTDUR24']
        
        # Convertir en dataframe
        self.user_data = pd.DataFrame(synthetic_data)
        
        # Calculer les statistiques des activités
        self._compute_activity_statistics()
    
    def _compute_activity_statistics(self):
        """Calcule les statistiques des activités pour l'apprentissage des préférences."""
        # Grouper par type d'activité et jour de la semaine
        grouped = self.user_data.groupby(['ACTIVITY_NAME', 'TUDIARYDAY'])
        
        # Calculer la durée moyenne par activité et par jour
        self.avg_duration = grouped['TUACTDUR24'].mean().reset_index()
        
        # Calculer l'heure de début moyenne par activité et par jour
        self.avg_start_time = grouped['start_time_minutes'].mean().reset_index()
        
        # Calculer la fréquence des activités par jour
        self.activity_frequency = grouped.size().reset_index(name='frequency')
    
    def reset(self):
        """Réinitialise l'environnement et retourne l'état initial."""
        # Choisir un jour aléatoire de la semaine (1-7)
        self.current_day = np.random.randint(1, 8)
        
        # Initialiser un agenda vide
        self.current_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Initialiser le temps disponible (24 heures = 24 créneaux)
        self.available_time = self.n_time_slots
        
        # Initialiser la liste des activités planifiées
        self.scheduled_activities = []
        
        # Créer un vecteur one-hot pour le jour de la semaine
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1  # -1 car l'indexation commence à 0
        
        # Retourner l'état initial
        return {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
    
    def step(self, action):
        """
        Exécute une action dans l'environnement et retourne le nouvel état,
        la récompense, le statut de fin et des informations supplémentaires.
        
        Action: (activité_id, créneau_horaire)
        """
        activity_id, time_slot = action
        activity_name = self.activity_types[activity_id]
        
        # Vérifier si le créneau horaire est disponible
        if self.current_schedule[time_slot].sum() > 0:
            reward = -1.0  # Pénalité pour conflit horaire
            done = False
            info = {'status': 'conflict', 'activity': activity_name, 'time_slot': time_slot}
        else:
            # Planifier l'activité
            self.current_schedule[time_slot, activity_id] = 1
            self.available_time -= 1
            self.scheduled_activities.append((activity_name, time_slot))
            
            # Calculer la récompense basée sur les préférences utilisateur
            reward = self._compute_reward(activity_name, time_slot)
            
            # Vérifier si toutes les activités ont été planifiées ou si le temps est écoulé
            done = len(self.scheduled_activities) >= self.max_activities or self.available_time <= 0
            
            info = {'status': 'scheduled', 'activity': activity_name, 'time_slot': time_slot}
        
        # Construire le nouvel état
        day_of_week = np.zeros(self.days_of_week)
        day_of_week[self.current_day - 1] = 1
        
        state = {
            'schedule': self.current_schedule.astype(np.float32),
            'day_of_week': day_of_week.astype(np.float32),
            'time_remaining': np.array([self.available_time], dtype=np.float32)
        }
        
        return state, reward, done, info
    
    def _compute_reward(self, activity_name, time_slot):
        """
        Calcule la récompense pour une activité planifiée à un créneau horaire spécifique,
        basé sur les préférences historiques de l'utilisateur.
        """
        # Convertir le créneau horaire en minutes (1 créneau = 1 heure = 60 minutes)
        scheduled_time = time_slot * 60
        
        # Trouver les statistiques pour cette activité et ce jour de la semaine
        act_stats = self.avg_start_time[
            (self.avg_start_time['ACTIVITY_NAME'] == activity_name) & 
            (self.avg_start_time['TUDIARYDAY'] == self.current_day)
        ]
        
        if not act_stats.empty:
            # Calculer la différence entre l'heure planifiée et l'heure préférée (en minutes)
            preferred_time = act_stats['start_time_minutes'].values[0]
            time_diff = abs(scheduled_time - preferred_time)
            
            # La récompense diminue avec l'écart par rapport à l'heure préférée
            # Normaliser pour que la récompense soit entre 0 et 1
            time_reward = max(0, 1 - (time_diff / (12 * 60)))  # max 12h de différence
        else:
            # Si nous n'avons pas d'information sur cette activité pour ce jour
            time_reward = 0.5  # Récompense neutre
        
        # Bonus pour une planification cohérente (activités similaires regroupées)
        coherence_reward = 0
        if len(self.scheduled_activities) > 0:
            for prev_activity, prev_slot in self.scheduled_activities:
                # Récompense pour les activités similaires regroupées
                if prev_activity == activity_name and abs(prev_slot - time_slot) <= 1:
                    coherence_reward += 0.2
                # Pénalité pour les activités qui devraient être espacées
                elif prev_activity == activity_name and abs(prev_slot - time_slot) < 3:
                    coherence_reward -= 0.1
        
        # La récompense finale est une combinaison de récompenses basées sur le temps et la cohérence
        reward = time_reward + coherence_reward
        
        return reward
    
    def render(self, mode='human'):
        """Affiche l'état actuel de l'environnement pour le débogage."""
        if mode != 'human':
            return
        
        print("\n===== ÉTAT ACTUEL DE L'AGENDA =====")
        print(f"Jour de la semaine: {self.current_day}")
        print(f"Temps restant: {self.available_time} créneaux")
        print("\nActivités planifiées:")
        
        for i, (activity, time_slot) in enumerate(self.scheduled_activities):
            print(f"{i+1}. {activity} à {time_slot}:00")
        
        print("\nGrille horaire:")
        for slot in range(self.n_time_slots):
            activities = [self.activity_types[i] for i in range(len(self.activity_types)) 
                         if self.current_schedule[slot, i] > 0]
            print(f"{slot}:00 - {activities if activities else 'Libre'}")
        
        print("====================================\n")
    
    def close(self):
        """Libère les ressources."""
        pass

    def get_optimal_schedule(self):
        """
        Génère un emploi du temps optimal basé sur les préférences utilisateur.
        Utilisé pour comparer les performances du modèle DQN.
        """
        # Créer un agenda vide
        optimal_schedule = np.zeros((self.n_time_slots, len(self.activity_types)))
        
        # Filtrer les activités pour le jour actuel
        day_activities = self.avg_start_time[self.avg_start_time['TUDIARYDAY'] == self.current_day]
        
        # Trier par fréquence (priorité aux activités les plus fréquentes)
        day_activities = day_activities.merge(self.activity_frequency, 
                                          on=['ACTIVITY_NAME', 'TUDIARYDAY'])
        day_activities = day_activities.sort_values('frequency', ascending=False)
        
        # Planifier les activités à leur heure préférée
        for _, row in day_activities.iterrows():
            activity_name = row['ACTIVITY_NAME']
            preferred_time_minutes = row['start_time_minutes']
            
            # Convertir en créneau horaire (arrondi à l'heure la plus proche)
            preferred_slot = int(round(preferred_time_minutes / 60)) % self.n_time_slots
            
            # Vérifier si le créneau est disponible
            if optimal_schedule[preferred_slot].sum() == 0:
                # Trouver l'index de l'activité
                activity_idx = np.where(self.activity_types == activity_name)[0][0]
                
                # Planifier l'activité
                optimal_schedule[preferred_slot, activity_idx] = 1
            else:
                # Chercher le créneau disponible le plus proche
                for offset in range(1, self.n_time_slots // 2):
                    # Essayer le créneau avant
                    before_slot = (preferred_slot - offset) % self.n_time_slots
                    if optimal_schedule[before_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[before_slot, activity_idx] = 1
                        break
                    
                    # Essayer le créneau après
                    after_slot = (preferred_slot + offset) % self.n_time_slots
                    if optimal_schedule[after_slot].sum() == 0:
                        activity_idx = np.where(self.activity_types == activity_name)[0][0]
                        optimal_schedule[after_slot, activity_idx] = 1
                        break
        
        return optimal_schedule
le voila mon code pour le fichiers 2_data_preprocessing.ipynb:
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
import os
import pickle
cols_to_load = [
    'TUACTDUR24',    # Durée de l'activité (en minutes)
    'ACTIVITY_NAME', # Nom de l'activité
    'TUSTARTTIM',    # Heure de début (format HH:MM:SS)
    'TUDIARYDAY'     # Jour de la semaine (1=dimanche, 7=samedi)
]
df = pd.read_csv("../Data/raw/atus_full_selected.csv", usecols=cols_to_load)
df.info(), df.describe(), df.head()
#2. Nettoyage des données
df.dropna(inplace=True)
df.reset_index(drop=True, inplace=True)
print(df.isnull().sum())
# Visualisation : distribution des durées d'activité
plt.figure(figsize=(10, 5))
sns.histplot(df['TUACTDUR24'], bins=50, kde=True)
plt.title("Distribution des durées d'activités (en minutes)")
plt.xlabel("Durée")
plt.ylabel("Fréquence")
plt.grid(True)
plt.tight_layout()
plt.show()
# 3. Conversion HH:MM:SS → minutes
def time_to_minutes(t):
    try:
        hh, mm, ss = map(int, t.split(':'))
        return hh * 60 + mm
    except:
        return 0  # Valeur par défaut
df['START_MINUTES'] = df['TUSTARTTIM'].apply(time_to_minutes)
 #Visualisation : heures de début d'activité
plt.figure(figsize=(10, 5))
sns.histplot(df['START_MINUTES'], bins=48, kde=True)
plt.title("Heures de début des activités (en minutes depuis minuit)")
plt.xlabel("Minutes depuis minuit")
plt.ylabel("Fréquence")
plt.grid(True)
plt.tight_layout()
plt.show()
# 4. Encodage des activités
activity_encoder = LabelEncoder()
df['ACTIVITY_CODE'] = activity_encoder.fit_transform(df['ACTIVITY_NAME'])

top_activities = df['ACTIVITY_NAME'].value_counts().nlargest(10)
plt.figure(figsize=(12, 6))
sns.barplot(x=top_activities.values, y=top_activities.index, palette="viridis")
plt.title("Top 10 des activités les plus fréquentes")
plt.xlabel("Nombre d’occurrences")
plt.ylabel("Activité")
plt.tight_layout()
plt.show()
# 5. Transformation du jour de la semaine
df['DAY_OF_WEEK'] = df['TUDIARYDAY'] - 1  # 0=dimanche, 6=samedi
df['IS_WEEKEND'] = (df['DAY_OF_WEEK'] >= 5).astype(int)
# Visualisation : répartition des jours
plt.figure(figsize=(8, 4))
sns.countplot(x='DAY_OF_WEEK', data=df, palette="pastel")
plt.title("Répartition des activités par jour de la semaine (0=dim, 6=sam)")
plt.xlabel("Jour de la semaine")
plt.ylabel("Nombre d’activités")
plt.tight_layout()
plt.show()
# Visualisation : proportion weekend/semaine
plt.figure(figsize=(6, 4))
df['IS_WEEKEND'].value_counts().plot.pie(autopct='%1.1f%%', labels=['Semaine', 'Weekend'], colors=['#66c2a5', '#fc8d62'])
plt.title("Proportion des activités semaine vs weekend")
plt.ylabel("")
plt.tight_layout()
plt.show()
# 6. Sélection finale des colonnes utiles
final_columns = [
    'ACTIVITY_CODE',
    'TUACTDUR24',
    'START_MINUTES',
    'DAY_OF_WEEK',
    'IS_WEEKEND'
]
final_df = df[final_columns]
# 7. Sauvegarde des données transformées
os.makedirs("../Data/processed", exist_ok=True)
final_df.to_csv("../Data/processed/cleaned_data.csv", index=False)
with open("../Data/processed/activity_encoder.pkl", "wb") as f:
    pickle.dump(activity_encoder, f)
le voila mon code pour le fichiers 3_dqn_training.ipynb:
import numpy as np
import pandas as pd
import tensorflow as tf
from collections import deque
import random
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import sys
# Ajouter le chemin du dossier parent (si besoin d'importer ScheduleEnv)
parent_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))
sys.path.append(parent_dir)
from environment.schedule_env import ScheduleEnv
# 1. Chargement des données
df = pd.read_csv("../Data/processed/cleaned_data.csv")

# 2. Initialiser l'environnement
env = ScheduleEnv(data_path="../Data/processed/cleaned_data.csv")
# Calculer la taille de l'état
n_activities = len(env.activity_types)
state_size = env.n_time_slots * n_activities + env.days_of_week + 1  # schedule + day_of_week + time_remaining
action_size = env.action_space.nvec[0] * env.action_space.nvec[1]  # Nombre total d'actions possibles

print(f"\n✅ Environnement créé avec {action_size} actions possibles")
# 3. Paramètres du DQN
memory = deque(maxlen=2000)
batch_size = 32
gamma = 0.95
epsilon = 1.0
epsilon_min = 0.01
epsilon_decay = 0.995
# 4. Création du modèle DQN
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, input_dim=state_size, activation='relu'),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(action_size, activation='linear')
])
model.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer=tf.keras.optimizers.Adam(0.001))

# Création du modèle cible
target_model = tf.keras.models.clone_model(model)
target_model.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer=tf.keras.optimizers.Adam(0.001))
target_model.set_weights(model.get_weights())
# 5. Fonction pour mettre à jour les graphiques
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plt.ion()
def update_plots(rewards, mean_rewards, epsilons, losses):
    ax1.clear()
    ax2.clear()
    
    ax1.plot(rewards, label='Récompense par épisode', alpha=0.4)
    ax1.plot(mean_rewards, label='Moyenne glissante (20)', color='red')
    ax1.set_title('Évolution des récompenses')
    ax1.set_xlabel('Épisode')
    ax1.set_ylabel('Récompense')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(epsilons, label='Epsilon', color='green')
    if losses:
        ax2.plot(losses, label='Perte (Loss)', color='orange')
    ax2.set_title("Évolution de l'epsilon et des pertes")
    ax2.set_xlabel("Épisode")
    ax2.legend()
    ax2.grid(True)

    plt.tight_layout()
    plt.draw()
    plt.pause(0.001)

# 6. Entraînement du DQN
def train_dqn(episodes=300):
    global epsilon
    rewards_history = []
    epsilons = []
    mean_rewards = []
    loss_history = []

    progress_bar = tqdm(range(episodes), desc="🔁 Entraînement DQN", unit="episode")

    for episode in progress_bar:
        state = env.reset()
        state_flat = np.concatenate([state['schedule'].flatten(), state['day_of_week'], state['time_remaining']])
        state = np.reshape(state_flat, [1, state_size])
        total_reward = 0
        done = False
        episode_loss = []

        while not done:
            if np.random.rand() <= epsilon:
                action = env.action_space.sample()
                action_idx = action[0] * env.n_time_slots + action[1]
            else:
                q_values = model.predict(state, verbose=0)[0]
                action_idx = np.argmax(q_values)
                action = np.array([action_idx // env.n_time_slots, action_idx % env.n_time_slots])

            next_state, reward, done, _ = env.step(action)
            next_state_flat = np.concatenate([
                next_state['schedule'].flatten(), 
                next_state['day_of_week'], 
                next_state['time_remaining']
            ])
            next_state = np.reshape(next_state_flat, [1, state_size])

            memory.append((state, action_idx, reward, next_state, done))
            state = next_state
            total_reward += reward

            if len(memory) >= batch_size:
                minibatch = random.sample(memory, batch_size)
                states = np.array([x[0][0] for x in minibatch])
                actions = np.array([x[1] for x in minibatch])
                rewards_batch = np.array([x[2] for x in minibatch])
                next_states = np.array([x[3][0] for x in minibatch])
                dones = np.array([x[4] for x in minibatch])

                targets = model.predict(states, verbose=0)
                next_q_values = target_model.predict(next_states, verbose=0)

                for i in range(batch_size):
                    if dones[i]:
                        targets[i][actions[i]] = rewards_batch[i]
                    else:
                        targets[i][actions[i]] = rewards_batch[i] + gamma * np.max(next_q_values[i])

                history = model.fit(states, targets, epochs=1, verbose=0)
                episode_loss.append(history.history['loss'][0])

        if episode % 10 == 0:
            target_model.set_weights(model.get_weights())

        epsilon = max(epsilon_min, epsilon * epsilon_decay)
        rewards_history.append(total_reward)
        epsilons.append(epsilon)
        loss_history.append(np.mean(episode_loss) if episode_loss else 0)

        window_size = 20
        if episode >= window_size:
            mean_rewards.append(np.mean(rewards_history[-window_size:]))
        else:
            mean_rewards.append(np.mean(rewards_history))

        progress_bar.set_postfix({
            'Reward': f"{total_reward:.1f}",
            'Epsilon': f"{epsilon:.2f}",
            'AvgReward': f"{mean_rewards[-1]:.1f}",
            'Loss': f"{loss_history[-1]:.4f}" if episode_loss else "N/A"
        })

        if episode % 10 == 0:
            update_plots(rewards_history, mean_rewards, epsilons, loss_history)

    plt.ioff()
    plt.show()
    return rewards_history, mean_rewards, loss_history

# 7. Lancer l'entraînement
print("\n🚀 Début de l'entraînement...")
rewards, avg_rewards, losses = train_dqn(episodes=300)
# 8. Sauvegarde du modèle
os.makedirs("../models", exist_ok=True)
model.save("../models/dqn_schedule_model.h5")
plt.figure(figsize=(10, 4))
plt.plot(rewards, label="Récompense par épisode", alpha=0.4)
plt.plot(avg_rewards, label="Récompense moyenne (20 épisodes)", color='red')
plt.title("Évolution des Récompenses")
plt.xlabel("Épisode")
plt.ylabel("Récompense")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 4))
plt.plot(losses, label="Perte moyenne", color='orange')
plt.title("Évolution de la Perte pendant l'Entraînement")
plt.xlabel("Épisode")
plt.ylabel("Loss")
plt.grid(True)
plt.show()
le voila mon code pour le fichiers app.py:
"""
Application Streamlit pour l'Assistant Personnel de Gestion du Temps
Utilise un modèle DQN pour optimiser les plannings personnels des utilisateurs
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow.keras.models import load_model
import sys
import os
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path

# Vérifier la version de TensorFlow
print(f"TensorFlow version: {tf.__version__}")

# Ajouter le répertoire parent au chemin pour importer les modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from environment.schedule_env import ScheduleEnv

# Configuration de la page
st.set_page_config(
    page_title="Assistant Personnel de Gestion du Temps",
    page_icon="📅",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Chemins de fichiers
MODEL_PATH = '../models/dqn_schedule_model.h5'
DATA_PATH = '../Data/processed/cleaned_data.csv'

# Vérification des fichiers
if not os.path.exists(MODEL_PATH):
    st.error(f"Le fichier modèle n'existe pas : {MODEL_PATH}")
if not os.path.exists(DATA_PATH):
    st.warning(f"Le fichier de données n'existe pas : {DATA_PATH}. Utilisation de données synthétiques.")

DEFAULT_ACTIVITIES = [
    'Travail', 'Repas', 'Transport', 'Loisirs', 'Sport', 
    'Sommeil', 'Tâches ménagères', 'Courses', 'Socialisation', 'Apprentissage'
]
ACTIVITY_COLORS = {
    'Travail': '#FF6B6B',
    'Repas': '#4ECDC4',
    'Transport': '#FFD166',
    'Loisirs': '#6B5B95',
    'Sport': '#88D8B0',
    'Sommeil': '#5D535E',
    'Tâches ménagères': '#F7B801',
    'Courses': '#F18701',
    'Socialisation': '#7BDFF2',
    'Apprentissage': '#B2DBBF'
}
DEFAULT_COLOR = '#CCCCCC'

# Fonction pour charger le modèle
@st.cache_resource
def load_dqn_model():
    """Charge le modèle DQN pré-entraîné"""
    try:
        model = load_model(MODEL_PATH)
        return model
    except Exception as e:
        st.error(f"Erreur lors du chargement du modèle: {str(e)}")
        return None

# Fonction pour charger les données
@st.cache_data
def load_data():
    """Charge les données prétraitées"""
    try:
        data = pd.read_csv(DATA_PATH)
        return data
    except Exception as e:
        st.warning(f"Erreur lors du chargement des données: {str(e)}")
        st.info("Utilisation de données par défaut")
        return None

# Créer un environnement Gym pour l'optimisation de planning
def create_environment(data=None, user_activities=None):
    """Crée l'environnement de simulation pour l'optimisation de planning"""
    if user_activities is None:
        user_activities = DEFAULT_ACTIVITIES
    
    env = ScheduleEnv(data_path=DATA_PATH if data is not None else None)
    
    if user_activities:
        env.activity_types = np.array(user_activities)
    
    return env

# Fonction pour générer un planning optimisé avec DQN
def generate_optimized_schedule(env, model, user_constraints=None, day_of_week=None):
    """
    Génère un planning optimisé en utilisant le modèle DQN
    
    Args:
        env: Environnement de simulation
        model: Modèle DQN pré-entraîné
        user_constraints: Dictionnaire de contraintes utilisateur
        day_of_week: Jour de la semaine spécifique (1-7, lundi-dimanche)
        
    Returns:
        schedule: Planning généré (matrice)
        activities: Liste des activités planifiées (avec heures et durées)
        rewards: Récompenses obtenues
    """
    state = env.reset()
    
    if day_of_week is not None:
        env.current_day = day_of_week
        day_of_week_vector = np.zeros(env.days_of_week)
        day_of_week_vector[env.current_day - 1] = 1
        state['day_of_week'] = day_of_week_vector
    
    if user_constraints:
        for activity, time_slots in user_constraints.items():
            if activity in env.activity_types:
                activity_idx = np.where(env.activity_types == activity)[0][0]
                for slot in time_slots:
                    if 0 <= slot < env.n_time_slots:
                        env.current_schedule[slot, activity_idx] = 1
                        env.available_time -= 1
    
    done = False
    total_reward = 0
    activities_planned = []
    
    while not done and env.available_time > 0:
        schedule_flat = state['schedule'].flatten()
        day_of_week = state['day_of_week']
        time_remaining = state['time_remaining']
        state_tensor = np.concatenate([schedule_flat, day_of_week, time_remaining])
        state_tensor = np.expand_dims(state_tensor, 0)
        
        act_values = model.predict(state_tensor, verbose=0)[0]
        
        n_activities = len(env.activity_types)
        action_idx = np.argmax(act_values)
        activity_id = action_idx // env.n_time_slots
        time_slot = action_idx % env.n_time_slots
        action = np.array([activity_id, time_slot])
        
        while env.current_schedule[action[1]].sum() > 0:
            act_values[action_idx] = -np.inf
            action_idx = np.argmax(act_values)
            activity_id = action_idx // env.n_time_slots
            time_slot = action_idx % env.n_time_slots
            action = np.array([activity_id, time_slot])
            
            if np.all(act_values == -np.inf):
                done = True
                break
        
        if not done:
            next_state, reward, done, info = env.step(action)
            
            state = next_state
            total_reward += reward
            
            activity_name = env.activity_types[action[0]]
            duration_stats = env.avg_duration[
                (env.avg_duration['ACTIVITY_NAME'] == activity_name) & 
                (env.avg_duration['TUDIARYDAY'] == env.current_day)
            ]
            duration = float(duration_stats['TUACTDUR24'].values[0]) if not duration_stats.empty else 60.0
            duration = min(duration, 240.0)  # Cap duration at 4 hours
            
            time_slot = action[1]
            activities_planned.append((activity_name, time_slot, reward, duration))
    
    return env.current_schedule, activities_planned, total_reward

# Fonction pour visualiser le planning avec Plotly
def visualize_schedule_plotly(schedule, activities, activity_types, reference_date="2025-05-12"):
    """Crée une visualisation interactive du planning avec Plotly"""
    from datetime import datetime, timedelta
    
    schedule_data = []
    
    for activity_name, time_slot, reward, duration in activities:
        # Calculate start time as a datetime
        start_hour = time_slot
        start_time = datetime.strptime(f"{reference_date} {start_hour:02d}:00", "%Y-%m-%d %H:%M")
        
        # Calculate end time
        end_time_minutes = time_slot * 60 + duration
        days_offset = int(end_time_minutes // 1440)  # Number of days to add if exceeding 24 hours
        end_time_minutes = end_time_minutes % 1440  # Minutes within the day
        end_hour = int(end_time_minutes // 60)
        end_minute = int(end_time_minutes % 60)
        
        # Parse end time, adjusting date if necessary
        end_date = datetime.strptime(reference_date, "%Y-%m-%d") + timedelta(days=days_offset)
        end_time = datetime.strptime(
            f"{end_date.strftime('%Y-%m-%d')} {end_hour:02d}:{end_minute:02d}", 
            "%Y-%m-%d %H:%M"
        )
        
        schedule_data.append({
            'Heure_Début': start_time,
            'Heure_Fin': end_time,
            'Activité': activity_name,
            'Valeur': 1,
            'Couleur': ACTIVITY_COLORS.get(activity_name, DEFAULT_COLOR)
        })
    
    if not schedule_data:
        st.warning("Aucune activité n'a pu être planifiée.")
        return go.Figure()
    
    schedule_df = pd.DataFrame(schedule_data)
    
    fig = px.timeline(
        schedule_df, 
        x_start="Heure_Début", 
        x_end="Heure_Fin", 
        y="Activité", 
        color="Activité",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Journalier Optimisé"
    )
    
    fig.update_layout(
        xaxis_title="Heure de la journée",
        yaxis_title="Activité",
        height=600,
        showlegend=True,
        xaxis=dict(
            tickformat="%H:%M",  # Display only time (HH:MM)
            tickangle=45
        )
    )
    
    return fig

# Fonction pour créer un calendrier hebdomadaire
def create_weekly_calendar(daily_schedules, activity_types, all_activities_planned):
    """Crée un calendrier hebdomadaire à partir des plannings quotidiens"""
    from datetime import datetime, timedelta
    
    days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']
    day_to_date = {
        'Lundi': '2025-05-12',
        'Mardi': '2025-05-13',
        'Mercredi': '2025-05-14',
        'Jeudi': '2025-05-15',
        'Vendredi': '2025-05-16',
        'Samedi': '2025-05-17',
        'Dimanche': '2025-05-18'
    }
    calendar_data = []
    
    for act, time_slot, reward, duration, day in all_activities_planned:
        day_name = days[day - 1]
        reference_date = day_to_date[day_name]
        
        start_time = datetime.strptime(f"{reference_date} {time_slot:02d}:00", "%Y-%m-%d %H:%M")
        
        end_time_minutes = time_slot * 60 + duration
        days_offset = int(end_time_minutes // 1440)
        end_time_minutes = end_time_minutes % 1440
        end_hour = int(end_time_minutes // 60)
        end_minute = int(end_time_minutes % 60)
        
        end_date = datetime.strptime(reference_date, "%Y-%m-%d") + timedelta(days=days_offset)
        end_time = datetime.strptime(
            f"{end_date.strftime('%Y-%m-%d')} {end_hour:02d}:{end_minute:02d}", 
            "%Y-%m-%d %H:%M"
        )
        
        calendar_data.append({
            'Jour': day_name,
            'Heure_Début': start_time,
            'Heure_Fin': end_time,
            'Activité': act,
            'Couleur': ACTIVITY_COLORS.get(act, DEFAULT_COLOR)
        })
    
    if not calendar_data:
        st.warning("Aucune activité n'a pu être planifiée pour la semaine.")
        return go.Figure()
    
    calendar_df = pd.DataFrame(calendar_data)
    
    fig = px.timeline(
        calendar_df, 
        x_start="Heure_Début", 
        x_end="Heure_Fin", 
        y="Jour", 
        color="Activité",
        color_discrete_map=ACTIVITY_COLORS,
        title="Planning Hebdomadaire Optimisé"
    )
    
    fig.update_layout(
        xaxis_title="Heure de la journée",
        yaxis_title="Jour de la semaine",
        height=600,
        showlegend=True,
        xaxis=dict(
            tickformat="%H:%M",
            tickangle=45
        )
    )
    
    return fig

# Fonction pour calculer des statistiques sur le planning
def calculate_schedule_stats(activities):
    """Calcule des statistiques sur le planning généré"""
    if not activities:
        return {}
    
    activity_counts = {}
    for activity, time_slot, reward, duration in activities:
        if activity in activity_counts:
            activity_counts[activity] += 1
        else:
            activity_counts[activity] = 1
    
    rewards_by_hour = {}
    for activity, time_slot, reward, duration in activities:
        if time_slot in rewards_by_hour:
            rewards_by_hour[time_slot] += reward
        else:
            rewards_by_hour[time_slot] = reward
    
    most_productive_hour = max(rewards_by_hour, key=rewards_by_hour.get) if rewards_by_hour else None
    
    return {
        'activity_counts': activity_counts,
        'rewards_by_hour': rewards_by_hour,
        'most_productive_hour': most_productive_hour
    }

# Interface utilisateur avec Streamlit
def main():
    st.title("📅 Assistant Personnel de Gestion du Temps")
    st.subheader("Optimisez votre planning quotidien avec l'intelligence artificielle")
    
    model = load_dqn_model()
    data = load_data()
    
    if model is None:
        st.error("Le modèle DQN n'a pas pu être chargé. Veuillez vérifier le fichier modèle.")
        return
    
    st.sidebar.title("Paramètres")
    
    planning_type = st.sidebar.radio(
        "Type de planning",
        ["📆 Planning quotidien", "🗓️ Planning hebdomadaire"]
    )
    
    day_options = {
        "Lundi": 1, "Mardi": 2, "Mercredi": 3, "Jeudi": 4, 
        "Vendredi": 5, "Samedi": 6, "Dimanche": 7
    }
    
    if planning_type == "📆 Planning quotidien":
        selected_day_name = st.sidebar.selectbox(
            "Jour de la semaine",
            list(day_options.keys())
        )
        selected_day = day_options[selected_day_name]
    else:
        selected_day = None
    
    st.sidebar.subheader("Activités personnalisées")
    
    use_default_activities = st.sidebar.checkbox("Utiliser les activités par défaut", value=True)
    
    if use_default_activities:
        activities = DEFAULT_ACTIVITIES
    else:
        custom_activities_input = st.sidebar.text_area(
            "Entrez vos activités (une par ligne)",
            value="\n".join(DEFAULT_ACTIVITIES)
        )
        activities = [act.strip() for act in custom_activities_input.split("\n") if act.strip()]
    
    st.sidebar.subheader("Liste des activités")
    for i, activity in enumerate(activities):
        color = ACTIVITY_COLORS.get(activity, DEFAULT_COLOR)
        st.sidebar.markdown(
            f"<div style='background-color:{color}; padding:5px; border-radius:5px; margin:2px 0;'>"
            f"{i+1}. {activity}</div>",
            unsafe_allow_html=True
        )
    
    st.sidebar.subheader("Contraintes (optionnel)")
    add_constraints = st.sidebar.checkbox("Ajouter des contraintes horaires")
    
    user_constraints = {}
    if add_constraints:
        constraint_activity = st.sidebar.selectbox(
            "Activité",
            activities
        )
        
        constraint_time = st.sidebar.multiselect(
            "Horaires (obligatoires)",
            [f"{h:02d}:00" for h in range(24)]
        )
        
        if st.sidebar.button("Ajouter cette contrainte"):
            time_slots = [int(t.split(":")[0]) for t in constraint_time]
            if constraint_activity in user_constraints:
                user_constraints[constraint_activity].extend(time_slots)
            else:
                user_constraints[constraint_activity] = time_slots
    
    if user_constraints:
        st.sidebar.subheader("Contraintes ajoutées")
        for activity, slots in user_constraints.items():
            st.sidebar.write(f"{activity}: {', '.join([f'{s:02d}:00' for s in slots])}")
    
    if planning_type == "📆 Planning quotidien":
        generate_button = st.sidebar.button("Générer planning quotidien")
    else:
        generate_button = st.sidebar.button("Générer planning hebdomadaire")
    
    if generate_button:
        with st.spinner("Génération du planning en cours..."):
            env = create_environment(data, activities)
            
            if planning_type == "📆 Planning quotidien":
                schedule, activities_planned, total_reward = generate_optimized_schedule(
                    env, model, user_constraints, selected_day
                )
                
                st.subheader(f"Planning optimisé pour {selected_day_name}")
                
                # Map selected day to a date (week of 2025-05-12)
                day_to_date = {
                    "Lundi": "2025-05-12",
                    "Mardi": "2025-05-13",
                    "Mercredi": "2025-05-14",
                    "Jeudi": "2025-05-15",
                    "Vendredi": "2025-05-16",
                    "Samedi": "2025-05-17",
                    "Dimanche": "2025-05-18"
                }
                reference_date = day_to_date[selected_day_name]
                
                fig = visualize_schedule_plotly(schedule, activities_planned, env.activity_types, reference_date)
                st.plotly_chart(fig, use_container_width=True)
                
                if activities_planned:
                    st.subheader("Détail des activités")
                    
                    activities_df = pd.DataFrame([
                        (act, f"{slot:02d}:00", f"{reward:.2f}", f"{duration:.0f} min") 
                        for act, slot, reward, duration in activities_planned
                    ], columns=["Activité", "Heure", "Score", "Durée"])
                    
                    st.dataframe(activities_df.sort_values(by="Heure"), use_container_width=True)
                    
                    stats = calculate_schedule_stats(activities_planned)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("Distribution des activités")
                        if stats['activity_counts']:
                            fig = px.pie(
                                values=list(stats['activity_counts'].values()),
                                names=list(stats['activity_counts'].keys()),
                                title="Distribution des activités",
                                color=list(stats['activity_counts'].keys()),
                                color_discrete_map=ACTIVITY_COLORS
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with col2:
                        st.subheader("Productivité par heure")
                        if stats['rewards_by_hour']:
                            hours = [f"{h:02d}:00" for h in stats['rewards_by_hour'].keys()]
                            rewards = list(stats['rewards_by_hour'].values())
                            
                            fig = px.bar(
                                x=hours,
                                y=rewards,
                                title="Score de productivité par heure",
                                labels={'x': 'Heure', 'y': 'Score de productivité'}
                            )
                            st.plotly_chart(fig, use_container_width=True)
                    
                    if stats['most_productive_hour'] is not None:
                        st.info(f"✨ Votre heure la plus productive est {stats['most_productive_hour']:02d}:00")
                
                st.subheader("Évaluation du planning")
                st.write(f"Score total du planning: {total_reward:.2f}")
                
                quality = min(max(total_reward / 10, 0), 1)
                
                gauge = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=quality * 100,
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': "Qualité du planning"},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 33], 'color': "red"},
                            {'range': [33, 66], 'color': "yellow"},
                            {'range': [66, 100], 'color': "green"}
                        ]
                    }
                ))
                
                st.plotly_chart(gauge, use_container_width=True)
                
                st.subheader("Recommandations")
                
                if quality < 0.4:
                    st.warning("Votre planning pourrait être amélioré. Essayez d'ajouter plus de contraintes ou de modifier vos activités.")
                elif quality < 0.7:
                    st.info("Votre planning est bon, mais il pourrait encore être optimisé.")
                else:
                    st.success("Excellent planning ! Votre journée est optimisée pour une productivité maximale.")
            
            else:
                st.subheader("Planning hebdomadaire optimisé")
                
                daily_schedules = []
                all_activities_planned = []
                total_weekly_reward = 0
                
                for day in range(1, 8):
                    day_schedule, day_activities, day_reward = generate_optimized_schedule(
                        env, model, user_constraints, day
                    )
                    daily_schedules.append(day_schedule)
                    all_activities_planned.extend([(act, slot, reward, duration, day) for act, slot, reward, duration in day_activities])
                    total_weekly_reward += day_reward
                
                fig = create_weekly_calendar(daily_schedules, env.activity_types, all_activities_planned)
                st.plotly_chart(fig, use_container_width=True)
                
                st.subheader("Statistiques hebdomadaires")
                
                activities_by_day = {}
                for day_idx in range(7):
                    day_name = list(day_options.keys())[day_idx]
                    day_activities = [act for act, _, _, _, day in all_activities_planned if day == day_idx + 1]
                    activities_by_day[day_name] = len(day_activities)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Activités par jour")
                    fig = px.bar(
                        x=list(activities_by_day.keys()),
                        y=list(activities_by_day.values()),
                        title="Nombre d'activités par jour",
                        labels={'x': 'Jour', 'y': 'Nombre d\'activités'}
                    )
                    st.plotly_chart(fig, use_container_width=True)
                
                with col2:
                    st.subheader("Score hebdomadaire")
                    st.write(f"Score total de la semaine: {total_weekly_reward:.2f}")
                    
                    quality = min(max(total_weekly_reward / 70, 0), 1)
                    
                    gauge = go.Figure(go.Indicator(
                        mode="gauge+number",
                        value=quality * 100,
                        domain={'x': [0, 1], 'y': [0, 1]},
                        title={'text': "Qualité du planning hebdomadaire"},
                        gauge={
                            'axis': {'range': [0, 100]},
                            'bar': {'color': "darkblue"},
                            'steps': [
                                {'range': [0, 33], 'color': "red"},
                                {'range': [33, 66], 'color': "yellow"},
                                {'range': [66, 100], 'color': "green"}
                            ]
                        }
                    ))
                    
                    st.plotly_chart(gauge, use_container_width=True)
                
                activity_counts = {}
                for act, _, _, _, _ in all_activities_planned:
                    if act in activity_counts:
                        activity_counts[act] += 1
                    else:
                        activity_counts[act] = 1
                
                st.subheader("Répartition des activités sur la semaine")
                fig = px.pie(
                    values=list(activity_counts.values()),
                    names=list(activity_counts.keys()),
                    title="Distribution des activités sur la semaine",
                    color=list(activity_counts.keys()),
                    color_discrete_map=ACTIVITY_COLORS
                )
                st.plotly_chart(fig, use_container_width=True)
                
                st.subheader("Exporter le planning")
                
                export_data = []
                days = list(day_options.keys())
                
                for day_idx, day_name in enumerate(days):
                    day_activities = [(act, slot, duration) for act, slot, _, duration, day in all_activities_planned if day == day_idx + 1]
                    for activity, time_slot, duration in day_activities:
                        export_data.append({
                            'Jour': day_name,
                            'Heure_Début': f"{time_slot:02d}:00",
                            'Durée': f"{duration:.0f} min",
                            'Activité': activity
                        })
                
                export_df = pd.DataFrame(export_data)
                
                csv = export_df.to_csv(index=False)
                st.download_button(
                    label="Télécharger le planning (CSV)",
                    data=csv,
                    file_name=f"planning_hebdomadaire_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv"
                )
    
    else:
        st.write("""
        Bienvenue dans votre Assistant Personnel de Gestion du Temps ! Cette application utilise l'intelligence artificielle
        pour vous aider à optimiser votre emploi du temps quotidien ou hebdomadaire.
        
        ### Comment ça marche ?
        
        Notre application utilise un algorithme d'apprentissage par renforcement appelé **Deep Q-Network (DQN)** pour analyser vos habitudes
        et préférences, puis générer un planning optimisé qui maximise votre productivité et votre satisfaction.
        
        ###Fonctionnalités
        
        - **Planning quotidien**: Obtenez un emploi du temps optimisé pour une journée spécifique
        - **Planning hebdomadaire**: Visualisez un calendrier complet pour toute la semaine
        - **Activités personnalisées**: Définissez vos propres types d'activités
        - **Contraintes horaires**: Ajoutez des activités obligatoires à des heures précises
        - **Statistiques**: Analysez la qualité de votre planning et identifiez vos heures les plus productives
        
        ###Commencer
        
        Utilisez les options dans la barre latérale pour personnaliser votre planning, puis cliquez sur "Générer planning" pour voir les résultats.
        """)
        
        st.image("../logo/4406306.png", 
                 caption="Optimisez votre temps avec l'IA")

if __name__ == "__main__":
    main()